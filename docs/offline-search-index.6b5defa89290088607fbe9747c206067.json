[{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/overview/","tags":"","title":"Overview"},{"body":"在 Linux 系统下，使用systemd 可以方便地控制 frp 服务端 frps 的启动和停止、配置后台运行和开启自启。\n要使用 systemd 来控制 frps，需要先安装 systemd，然后在 /etc/systemd/system 目录下创建一个 frps.service 文件。\n  如Linux服务端上没有安装 systemd，可以使用 yum 或 apt 等命令安装 systemd。\n# yum yum install systemd # apt apt install systemd   使用文本编辑器，如 vim 创建并编辑 frps.service 文件。\n$ vim /etc/systemd/system/frps.service 写入内容\n[Unit] # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target  [Service] Type = simple # 启动frps的命令，需修改为您的frps的安装路径 ExecStart = /path/to/frps -c /path/to/frps.ini  [Install] WantedBy = multi-user.target   使用 systemd 命令，管理 frps。\n# 启动frp systemctl start frps # 停止frp systemctl stop frps # 重启frp systemctl restart frps # 查看frp状态 systemctl status frps   配置 frps 开机自启。\nsystemctl enable frps   ","categories":"","description":"这个示例将会演示在 Linux 系统下使用 systemd 控制 frps 及配置开机自启。\n","excerpt":"这个示例将会演示在 Linux 系统下使用 systemd 控制 frps 及配置开机自启。\n","ref":"/docs/setup/systemd/","tags":"","title":"使用 systemd"},{"body":"基础配置    参数 类型 说明 默认值 可选值 备注     bind_addr string 服务端监听地址 0.0.0.0     bind_port int 服务端监听端口 7000  接收 frpc 的连接   bind_udp_port int 服务端监听 UDP 端口 0  用于辅助创建 P2P 连接   kcp_bind_port int 服务端监听 KCP 协议端口 0  用于接收采用 KCP 连接的 frpc   quic_bind_port int 服务端监听 QUIC 协议端口 0  用于接收采用 QUIC 连接的 frpc   quic_keepalive_period int quic 协议 keepalive 间隔，单位: 秒 10     quic_max_idle_timeout int quic 协议的最大空闲超时时间，单位: 秒 30     quic_max_incoming_streams int quic 协议最大并发 stream 数 100000     proxy_bind_addr string 代理监听地址 同 bind_addr  可以使代理监听在不同的网卡地址   log_file string 日志文件地址 ./frps.log  如果设置为 console，会将日志打印在标准输出中   log_level string 日志等级 info trace, debug, info, warn, error    log_max_days int 日志文件保留天数 3     disable_log_color bool 禁用标准输出中的日志颜色 false     detailed_errors_to_client bool 服务端返回详细错误信息给客户端 true     tcp_mux_keepalive_interval int tcp_mux 的心跳检查间隔时间 60  单位：秒   tcp_keepalive int 和客户端底层 TCP 连接的 keepalive 间隔时间，单位秒 7200  负数不启用   heartbeat_timeout int 服务端和客户端心跳连接的超时时间 90  单位：秒   user_conn_timeout int 用户建立连接后等待客户端响应的超时时间 10  单位：秒   udp_packet_size int 代理 UDP 服务时支持的最大包长度 1500  服务端和客户端的值需要一致   tls_cert_file string TLS 服务端证书文件路径      tls_key_file string TLS 服务端密钥文件路径      tls_trusted_ca_file string TLS CA 证书路径       权限验证    参数 类型 说明 默认值 可选值 备注     authentication_method string 鉴权方式 token token, oidc    authenticate_heartbeats bool 开启心跳消息鉴权 false     authenticate_new_work_conns bool 开启建立工作连接的鉴权 false     token string 鉴权使用的 token 值   客户端需要设置一样的值才能鉴权通过   oidc_issuer string oidc_issuer      oidc_audience string oidc_audience      oidc_skip_expiry_check bool oidc_skip_expiry_check      oidc_skip_issuer_check bool oidc_skip_issuer_check       管理配置    参数 类型 说明 默认值 可选值 备注     allow_ports string 允许代理绑定的服务端端口   格式为 1000-2000,2001,3000-4000   max_pool_count int 最大连接池大小 5     max_ports_per_client int 限制单个客户端最大同时存在的代理数 0  0 表示没有限制   tls_only bool 只接受启用了 TLS 的客户端连接 false      Dashboard, 监控    参数 类型 说明 默认值 可选值 备注     dashboard_addr string 启用 Dashboard 监听的本地地址 0.0.0.0     dashboard_port int 启用 Dashboard 监听的本地端口 0     dashboard_user string HTTP BasicAuth 用户名      dashboard_pwd string HTTP BasicAuth 密码      dashboard_tls_mode bool 是否启用 TLS 模式 false     dashboard_tls_cert_file string TLS 证书文件路径      dashboard_tls_key_file string TLS 密钥文件路径      enable_prometheus bool 是否提供 Prometheus 监控接口 false  需要同时启用了 Dashboard 才会生效   asserts_dir string 静态资源目录   Dashboard 使用的资源默认打包在二进制文件中，通过指定此参数使用自定义的静态资源   pprof_enable bool 启动 Go HTTP pprof false  用于应用调试    HTTP \u0026 HTTPS    参数 类型 说明 默认值 可选值 备注     vhost_http_port int 为 HTTP 类型代理监听的端口 0  启用后才支持 HTTP 类型的代理，默认不启用   vhost_https_port int 为 HTTPS 类型代理监听的端口 0  启用后才支持 HTTPS 类型的代理，默认不启用   vhost_http_timeout int HTTP 类型代理在服务端的 ResponseHeader 超时时间 60     subdomain_host string 二级域名后缀      custom_404_page string 自定义 404 错误页面地址       TCPMUX    参数 类型 说明 默认值 可选值 备注     tcpmux_httpconnect_port int 为 TCPMUX 类型代理监听的端口 0  启用后才支持 TCPMUX 类型的代理，默认不启用   tcpmux_passthrough bool 是否透传 CONNECT 请求 false  通常在本地服务是 HTTP Proxy 时使用    ","categories":"","description":"frp 服务端详细配置说明。\n","excerpt":"frp 服务端详细配置说明。\n","ref":"/docs/reference/server-configures/","tags":"","title":"服务端配置"},{"body":"frp 是什么？ frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。\n为什么使用 frp？ 通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：\n 客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。 采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。 代理组间的负载均衡。 端口复用，多个服务通过同一个服务端端口暴露。 多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。 高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。 服务端和客户端 UI 页面。  下一步？  安装：安装 frp。 示例：通过简单示例了解 frp 的应用场景。  ","categories":"","description":"一些概述，便于您快速的了解 frp。\n","excerpt":"一些概述，便于您快速的了解 frp。\n","ref":"/docs/overview/","tags":"","title":"概览"},{"body":"加密与压缩 每一个代理都可以选择是否启用加密和压缩的功能。\n加密算法采用 aes-128-cfb，压缩算法采用 snappy。\n在每一个代理的配置中使用如下参数指定：\n# frpc.ini [ssh] type = tcp local_port = 22 remote_port = 6000 use_encryption = true use_compression = true 通过设置 use_encryption = true，将 frpc 与 frps 之间的通信内容加密传输，将会有效防止传输内容被截取。\n如果传输的报文长度较长，通过设置 use_compression = true 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 CPU 资源。\nTCP 多路复用 客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 frp 可以承载更高的并发数。\n该功能默认启用，如需关闭，可以在 frps.ini 和 frpc.ini 中配置，该配置项在服务端和客户端必须一致：\n# frps.ini 和 frpc.ini 中 [common] tcp_mux = false 连接池 默认情况下，当用户请求建立连接后，frps 才会请求 frpc 主动与后端服务建立一个连接。当为指定的代理启用连接池后，frp 会预先和后端服务建立起指定数量的连接，每次接收到用户请求后，会从连接池中取出一个连接和用户连接关联起来，避免了等待与后端服务建立连接以及 frpc 和 frps 之间传递控制信息的时间。\n这一功能适合有大量短连接请求时开启。\n  首先可以在 frps.ini 中设置每个代理可以创建的连接池上限，避免大量资源占用，客户端设置超过此配置后会被调整到当前值：\n# frps.ini [common] max_pool_count = 5   在 frpc.ini 中为客户端启用连接池，指定预创建连接的数量：\n# frpc.ini [common] pool_count = 1   支持 KCP 协议 底层通信协议支持选择 KCP 协议，相比于 TCP，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。\n开启 KCP 协议支持：\n  在 frps.ini 中启用 KCP 协议支持，指定一个 udp 端口用于接收客户端请求：\n# frps.ini [common] bind_port = 7000 # kcp 绑定的是 udp 端口，可以和 bind_port 一样 kcp_bind_port = 7000   在 frpc.ini 指定需要使用的协议类型，其他代理配置不需要变更：\n# frpc.ini [common] server_addr = x.x.x.x # server_port 指定为 frps 的 kcp_bind_port server_port = 7000 protocol = kcp   支持 QUIC 协议 底层通信协议支持选择 QUIC 协议，底层采用 UDP 传输，解决了 TCP 上的一些问题，传输效率更高，连接延迟低。\n开启 QUIC 协议支持：\n  在 frps.ini 中启用 QUIC 协议支持，指定一个 udp 端口用于接收客户端请求：\n# frps.ini [common] bind_port = 7000 # quic 绑定的是 udp 端口，可以和 bind_port 一样 quic_bind_port = 7000   在 frpc.ini 指定需要使用的协议类型，其他代理配置不需要变更：\n# frpc.ini [common] server_addr = x.x.x.x # server_port 指定为 frps 的 quic_bind_port server_port = 7000 protocol = quic   ","categories":"","description":"","excerpt":"加密与压缩 每一个代理都可以选择是否启用加密和压缩的功能。\n加密算法采用 aes-128-cfb，压缩算法采用 snappy。\n在每一个代理 …","ref":"/docs/features/common/network/network/","tags":"","title":"通信安全及优化"},{"body":"","categories":"","description":"了解 frp 的一些通用功能。\n","excerpt":"了解 frp 的一些通用功能。\n","ref":"/docs/features/common/","tags":"","title":"通用功能"},{"body":"frp 目前仅支持 ini 格式的配置文件，frps 和 frpc 各自支持不同的参数。\nfrps 主要配置服务端的一些通用参数，frpc 则需要额外配置每一个代理的详细配置。\n格式 目前仅支持 ini 格式的配置，如下的示例配置将本地 SSH 服务穿透到公网。\nfrps 配置：\n[common] bind_port = 7000 frpc 配置：\n[common] server_addr = x.x.x.x server_port = 7000  [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [common] 是固定名称的段落，用于配置通用参数。\n[ssh] 仅在 frpc 中使用，用于配置单个代理的参数。代理名称必须唯一，不能重复。\n同一个客户端可以配置多个代理。\n模版渲染 配置文件支持使用环境变量进行模版渲染，模版格式采用 Go 的标准格式。\n示例配置如下：\n# frpc.ini [common] server_addr = {{ .Envs.FRP_SERVER_ADDR }} server_port = 7000  [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = {{ .Envs.FRP_SSH_REMOTE_PORT }} 启动 frpc 程序：\nexport FRP_SERVER_ADDR=\"x.x.x.x\" export FRP_SSH_REMOTE_PORT=\"6000\" ./frpc -c ./frpc.ini frpc 会自动使用环境变量渲染配置文件模版，所有环境变量需要以 .Envs 为前缀。\n配置校验 通过执行 frpc verify -c ./frpc.ini 或 frps verify -c ./frps.ini 可以对配置文件中的参数进行预先校验。\nfrpc: the configuration file ./frpc.ini syntax is ok 如果出现此结果，则说明新的配置文件没有错误，否则会输出具体的错误信息。\n配置拆分 通过 includes 参数可以在主配置中包含其他配置文件，从而实现将代理配置拆分到多个文件中管理。\n# frpc.ini [common] server_addr = x.x.x.x server_port = 7000 includes = ./confd/*.ini # ./confd/test.ini [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 上述配置在 frpc.ini 中通过 includes 额外包含了 ./confd 目录下所有的 ini 文件的代理配置内容，效果等价于将这两个文件合并成一个文件。\n需要注意的是 includes 指定的文件中只能包含代理配置，common 段落的配置只能放在主配置文件中。\n完整配置参数 由于 frp 目前支持的功能和配置项较多，未在文档中列出的功能参数可以在 参考 中查看。\n","categories":"","description":"","excerpt":"frp 目前仅支持 ini 格式的配置文件，frps 和 frpc 各自支持不同的参数。\nfrps 主要配置服务端的一些通用参数，frpc  …","ref":"/docs/features/common/configure/","tags":"","title":"配置文件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/setup/","tags":"","title":"Setup"},{"body":"TCP 和 UDP 是 frp 中两种最基础的代理类型，用于代理监听在 TCP 和 UDP 端口的服务。\n[ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 通过 type 指定代理类型。\nfrp 会为本地服务的 22 端口，在 frps 所在的服务端监听 6000 端口，将 6000 端口接收到的连接和本地服务的 22 端口关联，透传流量，从而实现让用户在外部访问到内部服务。\n","categories":"","description":"了解 frp `TCP`, `UDP` 类型的代理。\n","excerpt":"了解 frp `TCP`, `UDP` 类型的代理。\n","ref":"/docs/features/tcp-udp/","tags":"","title":"TCP \u0026 UDP"},{"body":"修改 Host Header 通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 HTTP 请求 header 中的 Host 字段来展现不同的网站，例如 nginx 的虚拟主机服务，启用 Host Header 的修改功能可以动态修改 HTTP 请求中的 Host 字段。需要注意的是，该功能仅限于 HTTP 类型的代理。\n# frpc.ini [web] type = http local_port = 80 custom_domains = test.yourdomain.com host_header_rewrite = dev.yourdomain.com 原来 HTTP 请求中的 Host 字段 test.yourdomain.com 转发到后端服务时会被替换为 dev.yourdomain.com。\n设置普通 Header 对于类型为 HTTP 的代理，可以设置在转发中动态添加的 Header 参数\n# frpc.ini [web] type = http local_port = 80 custom_domains = test.yourdomain.com host_header_rewrite = dev.yourdomain.com header_X-From-Where = frp 对于参数配置中所有以 header_ 开头的参数(支持同时配置多个)，都会被添加到 HTTP 请求的 Header 中，根据如上的配置，会在请求的 Header 中加上 X-From-Where: frp。\n","categories":"","description":"","excerpt":"修改 Host Header 通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 HTTP 请求 header …","ref":"/docs/features/http-https/header/","tags":"","title":"修改 HTTP 请求 Header"},{"body":" frp 采用 Golang 编写，支持跨平台，仅需下载对应平台的二进制文件即可执行，没有额外依赖。\n 系统需求 由于采用 Golang 编写，所以系统需求和最新的 Golang 对系统和平台的要求一致，具体可以参考 Golang System requirements。\n下载 目前可以在 Github 的 Release 页面中下载到最新版本的客户端和服务端二进制文件，所有文件被打包在一个压缩包中。\n部署 解压缩下载的压缩包，将其中的 frpc 拷贝到内网服务所在的机器上，将 frps 拷贝到具有公网 IP 的机器上，放置在任意目录。\n开始使用！ 编写配置文件，先通过 ./frps -c ./frps.ini 启动服务端，再通过 ./frpc -c ./frpc.ini 启动客户端。如果需要在后台长期运行，建议结合其他工具使用，例如 systemd 和 supervisor。\n如果是 Windows 用户，需要在 cmd 终端中执行命令。\n配置文件如何编写可以参考 示例 中的内容。\n","categories":"","description":"关于如何安装 frp 的说明。\n","excerpt":"关于如何安装 frp 的说明。\n","ref":"/docs/setup/","tags":"","title":"安装"},{"body":"基础配置    参数 类型 说明 默认值 可选值 备注     server_addr string 连接服务端的地址 0.0.0.0     server_port int 连接服务端的端口 7000     connect_server_local_ip string 连接服务端时所绑定的本地 IP      dial_server_timeout int 连接服务端的超时时间 10     dial_server_keepalive int 和服务端底层 TCP 连接的 keepalive 间隔时间，单位秒 7200  负数不启用   http_proxy string 连接服务端使用的代理地址   格式为 {protocol}://user:passwd@192.168.1.128:8080 protocol 目前支持 http、socks5、ntlm   log_file string 日志文件地址 ./frpc.log  如果设置为 console，会将日志打印在标准输出中   log_level string 日志等级 info trace, debug, info, warn, error    log_max_days int 日志文件保留天数 3     disable_log_color bool 禁用标准输出中的日志颜色 false     pool_count int 连接池大小 0     user string 用户名   设置此参数后，代理名称会被修改为 {user}.{proxyName}，避免代理名称和其他用户冲突   dns_server string 使用 DNS 服务器地址   默认使用系统配置的 DNS 服务器，指定此参数可以强制替换为自定义的 DNS 服务器地址   login_fail_exit bool 第一次登陆失败后是否退出 true     protocol string 连接服务端的通信协议 tcp tcp, kcp, quic, websocket    quic_keepalive_period int quic 协议 keepalive 间隔，单位: 秒 10     quic_max_idle_timeout int quic 协议的最大空闲超时时间，单位: 秒 30     quic_max_incoming_streams int quic 协议最大并发 stream 数 100000     tls_enable bool 启用 TLS 协议加密连接 false     tls_cert_file string TLS 客户端证书文件路径      tls_key_file string TLS 客户端密钥文件路径      tls_trusted_ca_file string TLS CA 证书路径      tls_server_name string TLS Server 名称   为空则使用 server_addr   disable_custom_tls_first_byte bool TLS 不发送 0x17 false  当为 true 时，不能端口复用   tcp_mux_keepalive_interval int tcp_mux 的心跳检查间隔时间 60  单位：秒   heartbeat_interval int 向服务端发送心跳包的间隔时间 30  建议启用 tcp_mux_keepalive_interval，将此值设置为 -1   heartbeat_timeout int 和服务端心跳的超时时间 90     udp_packet_size int 代理 UDP 服务时支持的最大包长度 1500  服务端和客户端的值需要一致   start string 指定启用部分代理   当配置了较多代理，但是只希望启用其中部分时可以通过此参数指定，默认为全部启用   meta_xxx map 附加元数据   会传递给服务端插件，提供附加能力    权限验证    参数 类型 说明 默认值 可选值 备注     authentication_method string 鉴权方式 token token, oidc 需要和服务端一致   authenticate_heartbeats bool 开启心跳消息鉴权 false  需要和服务端一致   authenticate_new_work_conns bool 开启建立工作连接的鉴权 false  需要和服务端一致   token string 鉴权使用的 token 值   需要和服务端设置一样的值才能鉴权通过   oidc_client_id string oidc_client_id      oidc_client_secret string oidc_client_secret      oidc_audience string oidc_audience      oidc_scope string oidc_scope      oidc_token_endpoint_url string oidc_token_endpoint_url      oidc_additional_xxx map OIDC 附加参数   map 结构，key 需要以 oidc_additional_ 开头    UI    参数 类型 说明 默认值 可选值 备注     admin_addr string 启用 AdminUI 监听的本地地址 0.0.0.0     admin_port int 启用 AdminUI 监听的本地端口 0     admin_user string HTTP BasicAuth 用户名      admin_pwd string HTTP BasicAuth 密码      asserts_dir string 静态资源目录   AdminUI 使用的资源默认打包在二进制文件中，通过指定此参数使用自定义的静态资源   pprof_enable bool 启动 Go HTTP pprof false  用于应用调试    ","categories":"","description":"frp 客户端的详细配置说明。\n","excerpt":"frp 客户端的详细配置说明。\n","ref":"/docs/reference/client-configures/","tags":"","title":"客户端配置"},{"body":"目前 frps 服务端支持内存和 Prometheus 两种监控系统。\n内存 内存中存储的监控数据主要用于 Dashboard 展示，当在 frps 配置中开启 Dashboard 功能后会默认开启内部的监控。\n内存中的监控数据每次重启进程后会清空，监控数据可以通过 Dashboard 的地址发送 HTTP 请求获取，但是目前此 API 尚不规范，不推荐直接使用。\nPrometheus 由于设计问题，Prometheus 对外提供的查询接口复用了 Dashboard 的地址，所以要使用 Prometheus 监控，必须要首先开启 Dashboard。\n在 frps.ini 中启用 Dashboard，并设置 enable_prometheus = true，则通过 http://{dashboard_addr}/metrics 可以获取到 Prometheus 的监控数据。\n","categories":"","description":"","excerpt":"目前 frps 服务端支持内存和 Prometheus 两种监控系统。\n内存 内存中存储的监控数据主要用于 Dashboard 展示， …","ref":"/docs/features/common/monitor/","tags":"","title":"监控"},{"body":"use_encryption 和 STCP 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存在被中间人攻击的威胁。为此 frp 支持 frpc 和 frps 之间的流量通过 TLS 协议加密，并且支持客户端或服务端单向验证，双向验证等功能。\n当 frpc.ini 的 common 中 tls_enable = true 时，表示开启 TLS 协议加密。\n当 frps.ini 的 common 中 tls_only = true 时，表示 server 端只接受 TLS 连接的客户端，这也是 frps 验证 frpc 身份的前提条件。如果 frps.ini 的 common 中 tls_trusted_ca_file 内容是有效的话，那么默认就会开启 tls_only = true。\n注意：启用此功能后除 xtcp 外，可以不用再设置 use_encryption 重复加密\nTLS 默认开启方式 # frpc.ini [common] tls_enable = true  frpc 开启 TLS 加密功能，但是默认不校验 frps 的证书。\nfrpc 单向校验 frps 身份 # frpc.ini [common] tls_enable = true tls_trusted_ca_file = /to/ca/path/ca.crt  # frps.ini [common] tls_cert_file = /to/cert/path/server.crt tls_key_file = /to/key/path/server.key frpc 需要额外加载 ca 证书，frps 需要额外指定 TLS 配置。frpc 通过 ca 证书单向验证 frps 的身份。这就要求 frps 的 server.crt 对 frpc 的 ca 是合法的。\n合法: 如果证书是 ca 签发的，或者证书是在 ca 的信任链中，那即认为: 该证书对 ca 而言是合法的。\nfrps 单向验证 frpc 的身份 # frpc.ini [common] tls_enable = true tls_cert_file = /to/cert/path/client.crt tls_key_file = /to/key/path/client.key  # frps.ini [common] tls_trusted_ca_file = /to/ca/path/ca.crt frpc 需要额外加载 TLS 配置，frps 需要额外加载 ca 证书。frps 通过 ca 证书单向验证 frpc 的身份。这就要求 frpc 的 client.crt 对 frps 的 ca 是合法的。\n双向验证 # frpc.ini [common] tls_enable = true tls_cert_file = /to/cert/path/client.crt tls_key_file = /to/key/path/client.key tls_trusted_ca_file = /to/ca/path/ca.crt  # frps.ini [common] tls_cert_file = /to/cert/path/server.crt tls_key_file = /to/key/path/server.key tls_trusted_ca_file = /to/ca/path/ca.crt 双向验证即 frpc 和 frps 通过本地 ca 证书去验证对方的身份。理论上 frpc 和 frps 的 ca 证书可以不同，只要能验证对方身份即可。\nOpenSSL 生成证书示例 x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0\n如果出现上述报错，是因为 go 1.15 版本开始废弃 CommonName，因此推荐使用 SAN 证书。 如果想兼容之前的方式，需要设置环境变量 GODEBUG 为 x509ignoreCN=0。\n下面简单示例如何用 openssl 生成 ca 和双方 SAN 证书。\n准备默认 OpenSSL 配置文件于当前目录。此配置文件在 linux 系统下通常位于 /etc/pki/tls/openssl.cnf，在 mac 系统下通常位于 /System/Library/OpenSSL/openssl.cnf。\n如果存在，则直接拷贝到当前目录，例如 cp /etc/pki/tls/openssl.cnf ./my-openssl.cnf。如果不存在可以使用下面的命令来创建。\ncat \u003e my-openssl.cnf \u003c\u003c EOF [ ca ] default_ca = CA_default [ CA_default ] x509_extensions = usr_cert [ req ] default_bits = 2048 default_md = sha256 default_keyfile = privkey.pem distinguished_name = req_distinguished_name attributes = req_attributes x509_extensions = v3_ca string_mask = utf8only [ req_distinguished_name ] [ req_attributes ] [ usr_cert ] basicConstraints = CA:FALSE nsComment = \"OpenSSL Generated Certificate\" subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer [ v3_ca ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = CA:true EOF 生成默认 ca:\nopenssl genrsa -out ca.key 2048 openssl req -x509 -new -nodes -key ca.key -subj \"/CN=example.ca.com\" -days 5000 -out ca.crt 生成 frps 证书:\nopenssl genrsa -out server.key 2048 openssl req -new -sha256 -key server.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\")) \\ -out server.csr openssl x509 -req -days 365 -sha256 \\ -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\") \\ -out server.crt 生成 frpc 的证书:\nopenssl genrsa -out client.key 2048 openssl req -new -sha256 -key client.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:client.com,DNS:example.client.com\")) \\ -out client.csr openssl x509 -req -days 365 -sha256 \\ -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:client.com,DNS:example.client.com\") \\ -out client.crt 在本例中，server.crt 和 client.crt 都是由默认 ca 签发的，因此他们对默认 ca 是合法的。\n","categories":"","description":"","excerpt":"use_encryption 和 STCP 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存在被中间人攻击的威 …","ref":"/docs/features/common/network/network-tls/","tags":"","title":"自定义 TLS 协议加密"},{"body":"  在具有公网 IP 的机器上部署 frps，修改 frps.ini 文件，这里使用了最简化的配置，设置了 frp 服务器用户接收客户端连接的端口：\n[common] bind_port = 7000   在需要被访问的内网机器上（SSH 服务通常监听在 22 端口）部署 frpc，修改 frpc.ini 文件，假设 frps 所在服务器的公网 IP 为 x.x.x.x：\n[common] server_addr = x.x.x.x server_port = 7000  [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 local_ip 和 local_port 配置为本地需要暴露到公网的服务地址和端口。remote_port 表示在 frp 服务端监听的端口，访问此端口的流量将会被转发到本地服务对应的端口。\n  分别启动 frps 和 frpc。\n  通过 SSH 访问内网机器，假设用户名为 test：\nssh -oPort=6000 test@x.x.x.x\nfrp 会将请求 x.x.x.x:6000 的流量转发到内网机器的 22 端口。\n  ","categories":"","description":"这个示例通过简单配置 TCP 类型的代理让用户访问到内网的服务器。\n","excerpt":"这个示例通过简单配置 TCP 类型的代理让用户访问到内网的服务器。\n","ref":"/docs/examples/ssh/","tags":"","title":"通过 SSH 访问内网机器"},{"body":"","categories":"","description":"Learn these concepts can help you use frp in a better way.\n","excerpt":"Learn these concepts can help you use frp in a better way.\n","ref":"/en/docs/concepts/","tags":"","title":"Concepts"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/examples/","tags":"","title":"Examples"},{"body":"HTTP 和 HTTPS 是 frp 中针对这两种协议额外提供了一些特殊的能力。本质上目前这两种应用层协议的底层协议都是 TCP。\n如果不需要用到相关的特殊功能，可以直接使用 TCP 类型的代理，更加简单方便。\nHTTP 和 HTTPS 协议的一个特点是发送的请求都具有 Host 字段，通过该字段描述要访问的服务。基于这个特点，frp 服务端只需要监听在一个端口(通过 vhost_http_port 和 vhost_https_port 指定)。就可以根据请求的 Host 来决定需要路由给哪一个代理，而不需要像 TCP 类型那样为每一个服务绑定一个端口。\n","categories":"","description":"了解 frp `HTTP`, `HTTPS` 类型的代理。\n","excerpt":"了解 frp `HTTP`, `HTTPS` 类型的代理。\n","ref":"/docs/features/http-https/","tags":"","title":"HTTP \u0026 HTTPS"},{"body":"通用配置 通用配置是指不同类型的代理共同使用的一些配置参数。\n基础配置    参数 类型 说明 是否必须 默认值 可选值 备注     type string 代理类型 是 tcp tcp, udp, http, https, stcp, sudp, xtcp, tcpmux    use_encryption bool 是否启用加密功能 否 false  启用后该代理和服务端之间的通信内容都会被加密传输   use_compression bool 是否启用压缩功能 否 false  启用后该代理和服务端之间的通信内容都会被压缩传输   proxy_protocol_version string 启用 proxy protocol 协议的版本 否  v1, v2 如果启用，则 frpc 和本地服务建立连接后会发送 proxy protocol 的协议，包含了原请求的 IP 地址和端口等内容   bandwidth_limit string 设置单个 proxy 的带宽限流 否   单位为 MB 或 KB，0 表示不限制，如果启用，会作用于对应的 frpc    本地服务配置 local_ip 和 plugin 的配置必须配置一个，且只能生效一个，如果配置了 plugin，则 local_ip 配置无效。\n   参数 类型 说明 是否必须 默认值 可选值 备注     local_ip string 本地服务 IP 是 127.0.0.1  需要被代理的本地服务的 IP 地址，可以为所在 frpc 能访问到的任意 IP 地址   local_port int 本地服务端口 是   配合 local_ip   plugin string 客户端插件名称 否  见客户端插件的功能说明 用于扩展 frpc 的能力，能够提供一些简单的本地服务，如果配置了 plugin，则 local_ip 和 local_port 无效，两者只能配置一个   plugin_params map 客户端插件参数 否   map 结构，key 需要都以 “plugin_” 开头，每一个 plugin 需要的参数也不一样，具体见客户端插件参数中的内容    负载均衡和健康检查    参数 类型 说明 是否必须 默认值 可选值 备注     group string 负载均衡分组名称 否   用户请求会以轮询的方式发送给同一个 group 中的代理   group_key string 负载均衡分组密钥 否   用于对负载均衡分组进行鉴权，group_key 相同的代理才会被加入到同一个分组中   health_check_type string 健康检查类型 否  tcp,http 配置后启用健康检查功能，tcp 是连接成功则认为服务健康，http 要求接口返回 2xx 的状态码则认为服务健康   health_check_timeout_s int 健康检查超时时间(秒) 否 3  执行检查任务的超时时间   health_check_max_failed int 健康检查连续错误次数 否 1  连续检查错误多少次认为服务不健康   health_check_interval_s int 健康检查周期(秒) 否 10  每隔多长时间进行一次健康检查   health_check_url string 健康检查的 HTTP 接口 否   如果 health_check_type 类型是 http，则需要配置此参数，指定发送 http 请求的 url，例如 “/health”    TCP    参数 类型 说明 是否必须 默认值 可选值 备注     remote_port int 服务端绑定的端口 是   用户访问此端口的请求会被转发到 local_ip:local_port    UDP    参数 类型 说明 是否必须 默认值 可选值 备注     remote_port int 服务端绑定的端口 是   用户访问此端口的请求会被转发到 local_ip:local_port    HTTP custom_domains 和 subdomain 必须要配置其中一个，两者可以同时生效。\n   参数 类型 说明 是否必须 默认值 可选值 备注     custom_domains []string 服务器绑定自定义域名 是(和 subdomain 两者必须配置一个)   用户通过 vhost_http_port 访问的 HTTP 请求如果 Host 在 custom_domains 配置的域名中，则会被路由到此代理配置的本地服务   subdomain string 自定义子域名 是(和 custom_domains 两者必须配置一个)   和 custom_domains 作用相同，但是只需要指定子域名前缀，会结合服务端的 subdomain_host 生成最终绑定的域名   locations []string URL 路由配置 否   采用最大前缀匹配的规则，用户请求匹配响应的 location 配置，则会被路由到此代理   route_by_http_user string 根据 HTTP Basic Auth user 路由 否      http_user string 用户名 否   如果配置此参数，暴露出去的 HTTP 服务需要采用 Basic Auth 的鉴权才能访问   http_pwd string 密码 否   结合 http_user 使用   host_header_rewrite string 替换 Host header 否   替换发送到本地服务 HTTP 请求中的 Host 字段   headers map 替换 header 否   map 中的 key 是要替换的 header 的 key，value 是替换后的内容    HTTPS custom_domains 和 subdomain 必须要配置其中一个，两者可以同时生效。\n   参数 类型 说明 是否必须 默认值 可选值 备注     custom_domains []string 服务器绑定自定义域名 是(和 subdomain 两者必须配置一个)   用户通过 vhost_http_port 访问的 HTTP 请求如果 Host 在 custom_domains 配置的域名中，则会被路由到此代理配置的本地服务   subdomain string 自定义子域名 是(和 custom_domains 两者必须配置一个)   和 custom_domains 作用相同，但是只需要指定子域名前缀，会结合服务端的 subdomain_host 生成最终绑定的域名    STCP    参数 类型 说明 是否必须 默认值 可选值 备注     role string 角色 是 server server,visitor server 表示服务端，visitor 表示访问端   sk string 密钥 是   服务端和访问端的密钥需要一致，访问端才能访问到服务端    SUDP    参数 类型 说明 是否必须 默认值 可选值 备注     role string 角色 是 server server,visitor server 表示服务端，visitor 表示访问端   sk string 密钥 是   服务端和访问端的密钥需要一致，访问端才能访问到服务端    XTCP    参数 类型 说明 是否必须 默认值 可选值 备注     role string 角色 是 server server,visitor server 表示服务端，visitor 表示访问端   sk string 密钥 是   服务端和访问端的密钥需要一致，访问端才能访问到服务端    TCPMUX custom_domains 和 subdomain 必须要配置其中一个，两者可以同时生效。\n   参数 类型 说明 是否必须 默认值 可选值 备注     multiplexer string 复用器类型 是  httpconnect    custom_domains []string 服务器绑定自定义域名 是(和 subdomain 两者必须配置一个)   用户通过 tcpmux_httpconnect_port 访问的 CONNECT 请求如果 Host 在 custom_domains 配置的域名中，则会被路由到此代理配置的本地服务   subdomain string 自定义子域名 是(和 custom_domains 两者必须配置一个)   和 custom_domains 作用相同，但是只需要指定子域名前缀，会结合服务端的 subdomain_host 生成最终绑定的域名   route_by_http_user string 根据 HTTP Basic Auth user 路由 否       ","categories":"","description":"frp 代理的详细配置说明。\n","excerpt":"frp 代理的详细配置说明。\n","ref":"/docs/reference/proxy/","tags":"","title":"代理配置"},{"body":"原理 frp 主要由 客户端(frpc) 和 服务端(frps) 组成，服务端通常部署在具有公网 IP 的机器上，客户端通常部署在需要穿透的内网服务所在的机器上。\n内网服务由于没有公网 IP，不能被非局域网内的其他用户访问。\n用户通过访问服务端的 frps，由 frp 负责根据请求的端口或其他信息将请求路由到对应的内网机器，从而实现通信。\n代理 在 frp 中一个代理对应一个需要暴露的内网服务。一个客户端支持同时配置多个代理。\n代理类型 frp 支持多种代理类型来适配不同的使用场景。\n   类型 描述     tcp 单纯的 TCP 端口映射，服务端会根据不同的端口路由到不同的内网服务。   udp 单纯的 UDP 端口映射，服务端会根据不同的端口路由到不同的内网服务。   http 针对 HTTP 应用定制了一些额外的功能，例如修改 Host Header，增加鉴权。   https 针对 HTTPS 应用定制了一些额外的功能。   stcp 安全的 TCP 内网代理，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。   sudp 安全的 UDP 内网代理，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。   xtcp 点对点内网穿透代理，功能同 stcp，但是流量不需要经过服务器中转。   tcpmux 支持服务端 TCP 端口的多路复用，通过同一个端口访问不同的内网服务。    ","categories":"","description":"一些概念，理解它们有助于您更好地了解和使用 frp。\n","excerpt":"一些概念，理解它们有助于您更好地了解和使用 frp。\n","ref":"/docs/concepts/","tags":"","title":"概念"},{"body":"由于所有客户端共用一个 frps 的 HTTP 服务端口，任何知道你的域名和 URL 的人都能访问到你部署在内网的服务，但是在某些场景下需要确保只有限定的用户才能访问。\nfrp 支持通过 HTTP Basic Auth 来保护你的 web 服务，使用户需要通过用户名和密码才能访问到你的服务。\n该功能目前仅限于 HTTP 类型的代理，需要在 frpc 的代理配置中添加用户名和密码的设置。\n# frpc.ini [web] type = http local_port = 80 custom_domains = test.yourdomain.com http_user = abc http_pwd = abc 通过浏览器访问 http://test.yourdomain.com，需要输入配置的用户名和密码才能访问。\n","categories":"","description":"","excerpt":"由于所有客户端共用一个 frps 的 HTTP 服务端口，任何知道你的域名和 URL 的人都能访问到你部署在内网的服务，但是在某些场景下需要 …","ref":"/docs/features/http-https/auth/","tags":"","title":"设置 BasicAuth 鉴权"},{"body":"目前 frpc 和 frps 之间支持两种身份验证方式，token 和 oidc，默认为 token。\n通过 frpc.ini 和 frps.ini 的 [common] 段落中配置 authentication_method 来指定要使用的身份验证方式。\n只有通过身份验证的客户端(frpc)才能成功连接 frps。\nToken 基于 Token 的身份验证方式比较简单，需要在 frpc 和 frps 的 [common] 段落中配置上相同的 token 参数即可。\nOIDC OIDC 是 OpenID Connect 的简称，验证流程参考 Client Credentials Grant。\n启用这一验证方式，参考配置如下：\n# frps.ini [common] authentication_method = oidc oidc_issuer = https://example-oidc-issuer.com/ oidc_audience = https://oidc-audience.com/.default # frpc.ini [common] authentication_method = oidc oidc_client_id = 98692467-37de-409a-9fac-bb2585826f18 # Replace with OIDC client ID oidc_client_secret = oidc_secret oidc_audience = https://oidc-audience.com/.default oidc_token_endpoint_url = https://example-oidc-endpoint.com/oauth2/v2.0/token 参数说明    类型 描述     authentication_method 身份验证方式，token 或 oidc，默认为 token。   authenticate_heartbeats 在每一个心跳包中附加上身份认证信息，客户端服务端需要一致。   authenticate_new_work_conns 在每次创建工作连接时附加上身份认证信息，客户端服务端需要一致。    ","categories":"","description":"","excerpt":"目前 frpc 和 frps 之间支持两种身份验证方式，token 和 oidc，默认为 token。\n通过 frpc.ini …","ref":"/docs/features/common/authentication/","tags":"","title":"身份认证"},{"body":"HTTP 类型的代理相比于 TCP 类型，不仅在服务端只需要监听一个额外的端口 vhost_http_port 用于接收 HTTP 请求，还额外提供了基于 HTTP 协议的诸多功能。\n  修改 frps.ini 文件，设置监听 HTTP 请求端口为 8080：\n[common] bind_port = 7000 vhost_http_port = 8080   修改 frpc.ini 文件，假设 frps 所在的服务器的 IP 为 x.x.x.x，local_port 为本地机器上 Web 服务监听的端口, 绑定自定义域名为 custom_domains。\n[common] server_addr = x.x.x.x server_port = 7000  [web] type = http local_port = 80 custom_domains = www.yourdomain.com  [web2] type = http local_port = 8080 custom_domains = www.yourdomain2.com   分别启动 frps 和 frpc。\n  将 www.yourdomain.com 和 www.yourdomain2.com 的域名 A 记录解析到 IP x.x.x.x，如果服务器已经有对应的域名，也可以将 CNAME 记录解析到服务器原先的域名。或者可以通过修改 HTTP 请求的 Host 字段来实现同样的效果。\n  通过浏览器访问 http://www.yourdomain.com:8080 即可访问到处于内网机器上 80 端口的服务，访问 http://www.yourdomain2.com:8080 则访问到内网机器上 8080 端口的服务。\n  ","categories":"","description":"这个示例通过简单配置 HTTP 类型的代理让用户访问到内网的 Web 服务。\n","excerpt":"这个示例通过简单配置 HTTP 类型的代理让用户访问到内网的 Web 服务。\n","ref":"/docs/examples/vhost-http/","tags":"","title":"通过自定义域名访问内网的 Web 服务"},{"body":"STCP 和 SUDP 的 (S) 的含义是 Secret。其作用是为 TCP 和 UDP 类型的服务提供一种安全访问的能力，避免让端口直接暴露在公网上导致任何人都能访问到。\n这两种代理要求在被访问服务的机器上以及要访问的用户的机器上都部署上 frp 的客户端。被访问的服务所在机器叫做服务端，另一端叫做访问端。\nfrp 会在访问端监听一个端口和服务端的端口做映射。访问端的用户需要提供相同的密钥才能连接成功，从而保证安全性。\n","categories":"","description":"了解 frp `STCP`, `SUDP` 类型的代理。\n","excerpt":"了解 frp `STCP`, `SUDP` 类型的代理。\n","ref":"/docs/features/stcp-sudp/","tags":"","title":"STCP \u0026 SUDP"},{"body":"目前 frpc 和 frps 分别内置了相应的 Web 界面方便用户使用。\n服务端 Dashboard 服务端 Dashboard 使用户可以通过浏览器查看 frp 的状态以及代理统计信息。\n注：Dashboard 尚未针对大量的 proxy 数据展示做优化，如果出现 Dashboard 访问较慢的情况，请不要启用此功能。\n需要在 frps.ini 中指定 dashboard 服务使用的端口，即可开启此功能：\n# frps.ini [common] dashboard_port = 7500 # dashboard 用户名密码，可选，默认为空 dashboard_user = admin dashboard_pwd = admin 打开浏览器通过 http://[server_addr]:7500 访问 Dashboard 界面，输入用户名密码 admin。\n你也可以通过配置 TLS 证书来启用 HTTPS 接口:\ndashboard_tls_mode = true dashboard_tls_cert_file = server.crt dashboard_tls_key_file = server.key 客户端管理界面 frpc 内置的 Admin UI 可以帮助用户通过浏览器来查询和管理客户端的 proxy 状态和配置。\n需要在 frpc.ini 中指定 admin 服务使用的端口，即可开启此功能：\n# frpc.ini [common] admin_addr = 127.0.0.1 admin_port = 7400 admin_user = admin admin_pwd = admin 打开浏览器通过 http://127.0.0.1:7400 访问 Admin UI。\n如果想要在外网环境访问 Admin UI，可以将 7400 端口通过 frp 映射出去即可，但需要重视安全风险。\n# frpc.ini [admin_ui] type = tcp local_port = 7400 remote_port = 7400 ","categories":"","description":"","excerpt":"目前 frpc 和 frps 分别内置了相应的 Web 界面方便用户使用。\n服务端 Dashboard 服务端 Dashboard 使用户可 …","ref":"/docs/features/common/ui/","tags":"","title":"Web 界面"},{"body":"","categories":"","description":"这里包括多个常见的使用场景和配置示例，你可以用来亲自部署和体验这些示例。\n","excerpt":"这里包括多个常见的使用场景和配置示例，你可以用来亲自部署和体验这些示例。\n","ref":"/docs/examples/","tags":"","title":"示例"},{"body":"在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。\n通过在 frps 的配置文件中配置 subdomain_host，就可以启用该特性。之后在 frpc 的 http、https 类型的代理中可以不配置 custom_domains，而是配置一个 subdomain 参数。\n只需要将 *.{subdomain_host} 解析到 frps 所在服务器。之后用户可以通过 subdomain 自行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomain_host} 来访问自己的 web 服务。\n# frps.ini [common] subdomain_host = frps.com 将泛域名 *.frps.com 解析到 frps 所在服务器的 IP 地址。\n# frpc.ini [web] type = http local_port = 80 subdomain = test frps 和 frpc 都启动成功后，通过 test.frps.com 就可以访问到内网的 web 服务。\n注：如果 frps 配置了 subdomain_host，则 custom_domains 中不能是属于 subdomain_host 的子域名或者泛域名。\n同一个 HTTP 或 HTTPS 类型的代理中 custom_domains 和 subdomain 可以同时配置。\n","categories":"","description":"","excerpt":"在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。\n通过在 frps …","ref":"/docs/features/http-https/subdomain/","tags":"","title":"自定义二级域名"},{"body":"DNS 查询请求通常使用 UDP 协议，frp 支持对内网 UDP 服务的穿透，配置方式和 TCP 基本一致。\n  frps.ini 内容如下：\n[common] bind_port = 7000   frpc.ini 内容如下：\n[common] server_addr = x.x.x.x server_port = 7000  [dns] type = udp local_ip = 8.8.8.8 local_port = 53 remote_port = 6000 这里反代了 Google 的 DNS 查询服务器的地址，仅仅用于测试 UDP 代理，并无实际意义。\n  分别启动 frps 和 frpc。\n  通过 dig 测试 UDP 包转发是否成功，预期会返回 www.baidu.com 域名的解析结果。\ndig @x.x.x.x -p 6000 www.baidu.com\n  ","categories":"","description":"这个示例通过简单配置 UDP 类型的代理转发 DNS 查询请求。\n","excerpt":"这个示例通过简单配置 UDP 类型的代理转发 DNS 查询请求。\n","ref":"/docs/examples/dns/","tags":"","title":"转发 DNS 查询请求"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/features/","tags":"","title":"Features"},{"body":"XTCP 的配置方式和 STCP 很类似。但是会采用 P2P 的方式进行打洞穿透，如果成功，后续的流量将不会经过 frps，而是直接通信，不再受到 frps 所在服务器的带宽限制。\n由于打洞成功率较低，所以 XTCP 的可用性和稳定性无法保证。在需要可靠连接的情况下，建议使用 STCP 替代。\n","categories":"","description":"了解 frp `XTCP` 类型的代理。\n","excerpt":"了解 frp `XTCP` 类型的代理。\n","ref":"/docs/features/xtcp/","tags":"","title":"XTCP"},{"body":"","categories":"","description":"了解 frp 所支持的一些功能特性。\n","excerpt":"了解 frp 所支持的一些功能特性。\n","ref":"/docs/features/","tags":"","title":"功能特性"},{"body":"URL 路由 frp 支持根据请求的 URL 路径路由转发到不同的后端服务。\n通过配置文件中的 locations 字段指定一个或多个 proxy 能够匹配的 URL 前缀(目前仅支持最大前缀匹配，之后会考虑正则匹配)。例如指定 locations = /news，则所有 URL 以 /news 开头的请求都会被转发到这个服务。\n# frpc.ini [web01] type = http local_port = 80 custom_domains = web.yourdomain.com locations = /  [web02] type = http local_port = 81 custom_domains = web.yourdomain.com locations = /news,/about 按照上述的示例配置后，web.yourdomain.com 这个域名下所有以 /news 以及 /about 作为前缀的 URL 请求都会被转发到 web02，其余的请求会被转发到 web01。\n","categories":"","description":"","excerpt":"URL 路由 frp 支持根据请求的 URL 路径路由转发到不同的后端服务。\n通过配置文件中的 locations …","ref":"/docs/features/http-https/route/","tags":"","title":"路由"},{"body":"  frps.ini 内容如下：\n[common] bind_port = 7000   frpc.ini 内容如下：\n[common] server_addr = x.x.x.x server_port = 7000  [unix_domain_socket] type = tcp remote_port = 6000 plugin = unix_domain_socket plugin_unix_path = /var/run/docker.sock   分别启动 frps 和 frpc。\n  通过 curl 命令查看 docker 版本信息\ncurl http://x.x.x.x:6000/version\n  ","categories":"","description":"这个示例通过配置 Unix域套接字客户端插件来通过 TCP 端口访问内网的 Unix域套接字服务，例如 Docker Daemon。\n","excerpt":"这个示例通过配置 Unix域套接字客户端插件来通过 TCP 端口访问内网的 Unix域套接字服务，例如 Docker Daemon。\n","ref":"/docs/examples/unix-domain-socket/","tags":"","title":"转发 Unix 域套接字"},{"body":"","categories":"","description":"提供更丰富的通信协议和安全。\n","excerpt":"提供更丰富的通信协议和安全。\n","ref":"/docs/features/common/network/","tags":"","title":"通信安全及优化"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/reference/","tags":"","title":"Reference"},{"body":"frp 支持将单个端口收到的连接路由到不同的代理，类似 vhost_http_port 和 vhost_https_port。\n目前支持的复用器只有 httpconnect。\n当在 frps.ini 的 [common] 中设置 tcpmux_httpconnect_port，frps 将会监听在这个端口，接收 HTTP CONNECT 请求。\nfrps 会根据 HTTP CONNECT 请求中的 host 路由到不同的后端代理。\n示例配置如下：\n# frps.ini [common] bind_port = 7000 tcpmux_httpconnect_port = 1337 # frpc.ini [common] server_addr = x.x.x.x server_port = 7000  [proxy1] type = tcpmux multiplexer = httpconnect custom_domains = test1 local_port = 80  [proxy2] type = tcpmux multiplexer = httpconnect custom_domains = test2 local_port = 8080 通过上面的配置，frps 如果接收到 HTTP CONNECT 请求内容:\nCONNECT test1 HTTP/1.1\\r\\n\\r\\n 该连接将会被路由到 proxy1 。\n","categories":"","description":"了解 frp `TCPMUX` 类型的代理。\n","excerpt":"了解 frp `TCPMUX` 类型的代理。\n","ref":"/docs/features/tcpmux/","tags":"","title":"TCPMUX"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/reference/","tags":"","title":"参考"},{"body":"通过 static_file 插件可以对外提供一个简单的基于 HTTP 的文件访问服务。\n  frps.ini 内容如下：\n[common] bind_port = 7000   frpc.ini 内容如下：\n[common] server_addr = x.x.x.x server_port = 7000  [test_static_file] type = tcp remote_port = 6000 plugin = static_file # 要对外暴露的文件目录 plugin_local_path = /tmp/file # 用户访问 URL 中会被去除的前缀，保留的内容即为要访问的文件路径 plugin_strip_prefix = static plugin_http_user = abc plugin_http_passwd = abc   分别启动 frps 和 frpc。\n  通过浏览器访问 http://x.x.x.x:6000/static/ 来查看位于 /tmp/file 目录下的文件，会要求输入已设置好的用户名和密码。\n  ","categories":"","description":"这个示例通过配置 `static_file` 客户端插件来将本地文件暴露在公网上供其他人访问。\n","excerpt":"这个示例通过配置 `static_file` 客户端插件来将本地文件暴露在公网上供其他人访问。\n","ref":"/docs/examples/static-file/","tags":"","title":"对外提供简单的文件访问服务"},{"body":"负载均衡 可以将多个相同类型的代理加入到同一个 group 中，从而实现负载均衡的能力。\n目前支持的代理类型：tcp, http, tcpmux\n# frpc.ini [test1] type = tcp local_port = 8080 remote_port = 80 group = web group_key = 123  [test2] type = tcp local_port = 8081 remote_port = 80 group = web group_key = 123 用户连接 frps 服务器的 80 端口，frps 会将接收到的用户连接随机分发给其中一个存活的 proxy。这样可以在一台 frpc 机器挂掉后仍然有其他节点能够提供服务。\ntcp 类型代理要求 group_key 相同，做权限验证，且 remote_port 相同。\nhttp 类型代理要求 group_key, custom_domains 或 subdomain 和 locations 相同。\n健康检查 通过给代理配置健康检查的参数，可以在要反向代理的服务出现故障时，将这个服务从 frps 中摘除，搭配负载均衡的功能，可以用来实现高可用的架构，避免服务单点故障。\n在每一个 proxy 的配置下加上 health_check_type = {type} 来启用健康检查功能。\ntype 目前可选 tcp 和 http。\ntcp 只要能够建立连接则认为服务正常，http 会发送一个 http 请求，服务需要返回 2xx 的状态码才会被认为正常\ntcp 示例配置如下：\n# frpc.ini [test1] type = tcp local_port = 22 remote_port = 6000 # 启用健康检查，类型为 tcp health_check_type = tcp # 建立连接超时时间为 3 秒 health_check_timeout_s = 3 # 连续 3 次检查失败，此 proxy 会被摘除 health_check_max_failed = 3 # 每隔 10 秒进行一次健康检查 health_check_interval_s = 10 http 示例配置如下：\n# frpc.ini [web] type = http local_ip = 127.0.0.1 local_port = 80 custom_domains = test.yourdomain.com # 启用健康检查，类型为 http health_check_type = http # 健康检查发送 http 请求的 url，后端服务需要返回 2xx 的 http 状态码 health_check_url = /status health_check_interval_s = 10 health_check_max_failed = 3 health_check_timeout_s = 3 ","categories":"","description":"","excerpt":"负载均衡 可以将多个相同类型的代理加入到同一个 group 中，从而实现负载均衡的能力。\n目前支持的代理类型：tcp, http, …","ref":"/docs/features/common/load-balancer/","tags":"","title":"负载均衡与健康检查"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/faq/","tags":"","title":"FAQ"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/faq/","tags":"","title":"FAQ"},{"body":"  frps.ini 内容如下：\n[common] bind_port = 7000   frpc.ini 内容如下：\n[common] server_addr = x.x.x.x server_port = 7000  [test_htts2http] type = https custom_domains = test.yourdomain.com  plugin = https2http plugin_local_addr = 127.0.0.1:80  # HTTPS 证书相关的配置 plugin_crt_path = ./server.crt plugin_key_path = ./server.key plugin_host_header_rewrite = 127.0.0.1 plugin_header_X-From-Where = frp   分别启动 frps 和 frpc。\n  通过浏览器访问 https://test.yourdomain.com。\n  ","categories":"","description":"通过 `https2http` 插件可以让本地 HTTP 服务转换成 HTTPS 服务对外提供。\n","excerpt":"通过 `https2http` 插件可以让本地 HTTP 服务转换成 HTTPS 服务对外提供。\n","ref":"/docs/examples/https2http/","tags":"","title":"为本地 HTTP 服务启用 HTTPS"},{"body":"HTTP X-Forwarded-For 目前只有 HTTP 类型的代理支持这一功能，可以通过用户请求的 header 中的 X-Forwarded-For 来获取用户真实 IP，默认启用。\nProxy Protocol frp 支持通过 Proxy Protocol 协议来传递经过 frp 代理的请求的真实 IP，此功能支持所有以 TCP 为底层协议的类型，不支持 UDP。\nProxy Protocol 功能启用后，frpc 在和本地服务建立连接后，会先发送一段 Proxy Protocol 的协议内容给本地服务，本地服务通过解析这一内容可以获得访问用户的真实 IP。所以不仅仅是 HTTP 服务，任何的 TCP 服务，只要支持这一协议，都可以获得用户的真实 IP 地址。\n需要注意的是，在代理配置中如果要启用此功能，需要本地的服务能够支持 Proxy Protocol 这一协议，目前 nginx 和 haproxy 都能够很好的支持。\n这里以 HTTPS 类型为例:\n# frpc.ini [web] type = https local_port = 443 custom_domains = test.yourdomain.com  # 目前支持 v1 和 v2 两个版本的 proxy protocol 协议。 proxy_protocol_version = v2 只需要在代理配置中增加一行 proxy_protocol_version = v2 即可开启此功能。\n本地的 HTTPS 服务可以通过在 nginx 的配置中启用 Proxy Protocol 的解析并将结果设置在 X-Real-IP 这个 Header 中就可以在自己的 Web 服务中通过 X-Real-IP 获取到用户的真实 IP。\n","categories":"","description":"","excerpt":"HTTP X-Forwarded-For 目前只有 HTTP 类型的代理支持这一功能，可以通过用户请求的 header …","ref":"/docs/features/common/realip/","tags":"","title":"获取用户真实 IP"},{"body":"对于某些服务来说如果直接暴露于公网上将会存在安全隐患。\n使用 stcp(secret tcp) 类型的代理可以避免让任何人都能访问到要穿透的服务，但是访问者也需要运行另外一个 frpc 客户端。\n  frps.ini 内容如下：\n[common] bind_port = 7000   在需要暴露到内网的机器上部署 frpc，且配置如下：\n[common] server_addr = x.x.x.x server_port = 7000  [secret_ssh] type = stcp # 只有 sk 一致的用户才能访问到此服务 sk = abcdefg local_ip = 127.0.0.1 local_port = 22   在想要访问内网服务的机器上也部署 frpc，且配置如下：\n[common] server_addr = x.x.x.x server_port = 7000  [secret_ssh_visitor] type = stcp # stcp 的访问者 role = visitor # 要访问的 stcp 代理的名字 server_name = secret_ssh sk = abcdefg # 绑定本地端口用于访问 SSH 服务 bind_addr = 127.0.0.1 bind_port = 6000   通过 SSH 访问内网机器，假设用户名为 test：\nssh -oPort=6000 test@127.0.0.1\n  ","categories":"","description":"这个示例将会创建一个只有自己能访问到的 SSH 服务代理。\n","excerpt":"这个示例将会创建一个只有自己能访问到的 SSH 服务代理。\n","ref":"/docs/examples/stcp/","tags":"","title":"安全地暴露内网服务"},{"body":"在 frpc 的配置文件中可以指定映射多个端口，目前只支持 TCP 和 UDP 的代理类型。\n这一功能通过 range: 段落标记来实现，客户端会解析这个标记中的配置，将其拆分成多个 proxy，每一个 proxy 以数字为后缀命名。\n例如要映射本地 6000-6005, 6007 这7个端口，主要配置如下：\n# frpc.ini [range:test_tcp] type = tcp local_ip = 127.0.0.1 local_port = 6000-6005,6007 remote_port = 6000-6005,6007 实际连接成功后会创建 7 个 proxy，命名为 test_tcp_0, test_tcp_1 ... test_tcp_6。\n","categories":"","description":"","excerpt":"在 frpc 的配置文件中可以指定映射多个端口，目前只支持 TCP 和 UDP 的代理类型。\n这一功能通过 range: 段落标记来实现，客 …","ref":"/docs/features/common/range/","tags":"","title":"范围端口映射"},{"body":"热加载配置文件 当修改了 frpc 中的代理配置，可以通过 frpc reload 命令来动态加载配置文件，通常会在 10 秒内完成代理的更新。\n启用此功能需要在 frpc 中启用 admin 端口，用于提供 API 服务。配置如下：\n# frpc.ini [common] admin_addr = 127.0.0.1 admin_port = 7400 之后执行重启命令：\nfrpc reload -c ./frpc.ini\n等待一段时间后客户端会根据新的配置文件创建、更新、删除代理。\n需要注意的是，[common] 中的参数除了 start 外目前无法被修改。\n命令行查看代理状态 frpc 支持通过 frpc status -c ./frpc.ini 命令查看代理的状态信息，此功能需要在 frpc 中配置 admin 端口。\n通过代理连接 frps 在只能通过代理访问外网的环境内，frpc 支持通过 HTTP 或 SOCKS5 代理和 frps 建立连接。\n可以通过设置 HTTP_PROXY 系统环境变量或者通过在 frpc 的配置文件中设置 http_proxy 参数来使用此功能。\n仅在 protocol = tcp 时生效。\n# frpc.ini [common] server_addr = x.x.x.x server_port = 7000 http_proxy = http://user:pwd@192.168.1.128:8080 将 http_proxy 设置为 socks5://user:pwd@192.168.1.128:8080 也可以连接到 SOCKS5 代理。\n","categories":"","description":"","excerpt":"热加载配置文件 当修改了 frpc 中的代理配置，可以通过 frpc reload 命令来动态加载配置文件，通常会在 10 秒内完成代理的更 …","ref":"/docs/features/common/client/","tags":"","title":"客户端"},{"body":"frp 提供了一种新的代理类型 xtcp 用于应对在希望传输大量数据且流量不经过服务器的场景。\n使用方式同 stcp 类似，需要在两边都部署上 frpc 用于建立直接的连接。\n目前处于开发的初级阶段，并不能穿透所有类型的 NAT 设备，所以穿透成功率较低。穿透失败时可以尝试 stcp 的方式。\n  frps.ini 内容如下，需要额外配置监听一个 UDP 端口用于支持该类型的客户端：\n[common] bind_port = 7000 bind_udp_port = 7000   在需要暴露到外网的机器上部署 frpc，且配置如下：\n[common] server_addr = x.x.x.x server_port = 7000  [p2p_ssh] type = xtcp # 只有 sk 一致的用户才能访问到此服务 sk = abcdefg local_ip = 127.0.0.1 local_port = 22   在想要访问内网服务的机器上也部署 frpc，且配置如下：\n[common] server_addr = x.x.x.x server_port = 7000  [p2p_ssh_visitor] type = xtcp # xtcp 的访问者 role = visitor # 要访问的 xtcp 代理的名字 server_name = p2p_ssh sk = abcdefg # 绑定本地端口用于访问 ssh 服务 bind_addr = 127.0.0.1 bind_port = 6000   通过 SSH 访问内网机器，假设用户名为 test：\nssh -oPort=6000 test@127.0.0.1\n  ","categories":"","description":"这个示例将会演示一种不通过服务器中转流量的方式来访问内网服务。\n","excerpt":"这个示例将会演示一种不通过服务器中转流量的方式来访问内网服务。\n","ref":"/docs/examples/xtcp/","tags":"","title":"点对点内网穿透"},{"body":"端口白名单 为了防止端口被滥用，可以手动指定允许哪些端口被使用，在服务端配置中通过 allow_ports 来指定：\n# frps.ini [common] allow_ports = 2000-3000,3001,3003,4000-50000 allow_ports 可以配置允许使用的某个指定端口或者是一个范围内的所有端口，以 , 分隔，指定的范围以 - 分隔。\n端口复用 目前 frps 中的 vhost_http_port 和 vhost_https_port 支持配置成和 bind_port 为同一个端口，frps 会对连接的协议进行分析，之后进行不同的处理。\n例如在某些限制较严格的网络环境中，可以将 bind_port 和 vhost_https_port 都设置为 443。\n限速 代理限速 目前支持在客户端的代理配置中设置代理级别的限速，限制单个 proxy 可以占用的带宽。\n# frpc.ini [ssh] type = tcp local_port = 22 remote_port = 6000 bandwidth_limit = 1MB 在代理配置中增加 bandwidth_limit 字段启用此功能，目前仅支持 MB 和 KB 单位。\n","categories":"","description":"","excerpt":"端口白名单 为了防止端口被滥用，可以手动指定允许哪些端口被使用，在服务端配置中通过 allow_ports 来指定：\n# frps.ini …","ref":"/docs/features/common/server-manage/","tags":"","title":"服务端管理"},{"body":"默认情况下，frpc 只会转发请求到本地 TCP 或 UDP 端口，也就是通过 local_ip 和 local_port 指定的本地服务地址。\n通过客户端插件的功能将一些简单的本地服务内置在 frpc 中，可以帮助用户在只启动 frpc 的情况下实现原本需要额外启动其他服务才能实现的功能。\n在每一个代理的配置中，通过 plugin 指定需要使用的插件，插件的配置参数都以 plugin_ 开头。当启用客户端插件后，local_ip 和 local_port 不再需要配置。\n客户端插件可以被应用在任意类型的代理中，但是需要插件本身的协议能够支持。例如静态文件访问插件可以通过 TCP 或者 HTTP 的代理暴露出去。\n使用 http_proxy 插件的示例:\n# frpc.ini [http_proxy] type = tcp remote_port = 6000 plugin = http_proxy plugin_http_user = abc plugin_http_passwd = abc plugin_http_user 和 plugin_http_passwd 即为 http_proxy 插件可选的配置参数。\nhttp_proxy HTTP 代理插件，用于将内网机器作为 HTTP 代理暴露给其他服务，可以通过此代理访问到此内网机器能够访问到的其他服务。\n   参数 可选 描述     plugin_http_user 是 HTTP 代理用户名   plugin_http_passwd 是 HTTP 代理密码    socks5 SOCKS5 代理。\n   参数 可选 描述     plugin_user 是 连接代理的用户名   plugin_passwd 是 连接代理的密码    static_file 静态文件浏览服务，通过暴露一个简单的 HTTP 服务查看指定的目录下的文件。\n   参数 可选 描述     plugin_local_path 否 要对外暴露的文件目录   plugin_strip_prefix 是 用户请求的 URL 路径会被映射到本地文件，如果希望去除用户访问文件的前缀，需要配置此参数   plugin_http_user 是 HTTP BasicAuth 用户名   plugin_http_passwd 是 HTTP BasicAuth 密码    unix_domain_socket 代理本地 Unix 域套接字的服务。\n   参数 可选 描述     plugin_unix_path 否 本地 Unix 域套接字地址    http2https 将本地的 HTTPS 服务以 HTTP 的形式暴露出去。\n   参数 可选 描述     plugin_local_addr 否 本地服务地址   plugin_host_header_rewrite 是 如果配置，发送给本地服务的请求的 Host 字段会被修改   plugin_header_{header name} 是 发送给本地服务的请求会被加上指定的 header 字段    https2http 将本地的 HTTP 服务以 HTTPS 的形式暴露出去。\n   参数 可选 描述     plugin_local_addr 否 本地服务地址   plugin_crt_path 是 HTTPS 所需的证书文件，如果 crt 和 key 都为空，则使用自动生成的证书   plugin_key_path 是 HTTPS 所需的密钥文件   plugin_host_header_rewrite 是 如果配置，发送给本地服务的请求的 Host 字段会被修改   plugin_header_{header name} 是 发送给本地服务的请求会被加上指定的 header 字段    https2https 将本地的 HTTPS 服务以 HTTPS 的形式暴露出去。\n   参数 可选 描述     plugin_local_addr 否 本地服务地址   plugin_crt_path 是 HTTPS 所需的证书文件，如果 crt 和 key 都为空，则使用自动生成的证书   plugin_key_path 是 HTTPS 所需的密钥文件   plugin_host_header_rewrite 是 如果配置，发送给本地服务的请求的 Host 字段会被修改   plugin_header_{header name} 是 发送给本地服务的请求会被加上指定的 header 字段    ","categories":"","description":"","excerpt":"默认情况下，frpc 只会转发请求到本地 TCP 或 UDP 端口，也就是通过 local_ip 和 local_port 指定的本地服务地 …","ref":"/docs/features/common/client-plugin/","tags":"","title":"客户端插件"},{"body":"frp 服务端插件的作用是在不侵入自身代码的前提下，扩展 frp 服务端的能力。\nfrp 服务端插件会以单独进程的形式运行，并且监听在一个端口上，对外提供 RPC 接口，响应 frps 的请求。\nfrps 在执行某些操作前，会根据配置向服务端插件发送 RPC 请求，根据插件的响应来执行相应的操作。\nRPC 请求 服务端插件接收到操作请求后，可以给出三种回应。\n 拒绝操作，需要返回拒绝操作的原因。 允许操作，不需要修改操作内容。 允许操作，对操作请求进行修改后，返回修改后的内容。  接口 接口路径可以在 frps 配置中为每个插件单独配置，这里以 /handler 为例。\nRequest\nPOST /handler?version=0.1.0\u0026op=Login { \"content\": { ... // 具体的操作信息 } } 请求 Header X-Frp-Reqid: 用于追踪请求 Response\n非 200 的返回都认为是请求异常。\n拒绝执行操作\n{ \"reject\": true, \"reject_reason\": \"invalid user\" } 允许且内容不需要变动\n{ \"reject\": false, \"unchange\": true } 允许且需要替换操作内容\n{ \"unchange\": \"false\", \"content\": { ... // 替换后的操作信息，格式必须和请求时的一致 } } 操作类型 目前插件支持管理的操作类型有 Login、NewProxy、CloseProxy、Ping、NewWorkConn 和 NewUserConn。\nLogin 用户登录操作信息\n{ \"content\": { \"version\": \u003cstring\u003e, \"hostname\": \u003cstring\u003e, \"os\": \u003cstring\u003e, \"arch\": \u003cstring\u003e, \"user\": \u003cstring\u003e, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e, \"run_id\": \u003cstring\u003e, \"pool_count\": \u003cint\u003e, \"metas\": map\u003cstring\u003estring, \"client_address\": \u003cstring\u003e } } NewProxy 创建代理的相关信息\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"use_encryption\": \u003cbool\u003e, \"use_compression\": \u003cbool\u003e, \"group\": \u003cstring\u003e, \"group_key\": \u003cstring\u003e, // tcp and udp only \"remote_port\": \u003cint\u003e, // http and https only \"custom_domains\": []\u003cstring\u003e, \"subdomain\": \u003cstring\u003e, \"locations\": \u003cstring\u003e, \"http_user\": \u003cstring\u003e, \"http_pwd\": \u003cstring\u003e, \"host_header_rewrite\": \u003cstring\u003e, \"headers\": map\u003cstring\u003estring, // stcp only \"sk\": \u003cstring\u003e, // tcpmux only \"multiplexer\": \u003cstring\u003e \"metas\": map\u003cstring\u003estring } } CloseProxy 代理关闭。(仅用于通知)\n注意: 当单个 frpc 会注册大量 proxy 时，慎重使用此接口，可能会由于连接数超限而影响服务的可用性。\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e } } Ping 心跳相关信息\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewWorkConn 创建工作连接\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"run_id\": \u003cstring\u003e \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewUserConn 创建用户连接 (支持 tcp、stcp、https 和 tcpmux 协议)。\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"remote_addr\": \u003cstring\u003e } } frps 中插件配置 [common] bind_port = 7000  [plugin.user-manager] addr = 127.0.0.1:9000 path = /handler ops = Login  [plugin.port-manager] addr = https://127.0.0.1:9001 path = /handler ops = NewProxy tls_verify = true addr: 插件监听的网络地址，支持 HTTP 和 HTTPS，默认为 HTTP。 path: 插件监听的请求路径。 ops: 插件需要处理的操作列表，多个 op 以英文逗号分隔。 tls_verify: 如果是 HTTPS 协议，支持忽略 TLS 身份验证。\n元数据 为了减少 frps 的代码修改，同时提高管理插件的扩展能力，在 frpc 的配置文件中引入自定义元数据的概念。元数据会在调用 RPC 请求时发送给插件。\n元数据以 meta_ 开头，可以配置多个，元数据分为两种，一种配置在 common 下，一种配置在各个 proxy 中。\n# frpc.ini [common] server_addr = 127.0.0.1 server_port = 7000 user = fake meta_token = fake meta_version = 1.0.0 [ssh] type = tcp local_port = 22 remote_port = 6000 meta_id = 123 ","categories":"","description":"","excerpt":"frp 服务端插件的作用是在不侵入自身代码的前提下，扩展 frp 服务端的能力。\nfrp 服务端插件会以单独进程的形式运行，并且监听在一个端 …","ref":"/docs/features/common/server-plugin/","tags":"","title":"服务端插件"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/","tags":"","title":"Documentation"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/index.json","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/index.json","tags":"","title":""},{"body":" 简单、高效的内网穿透工具 起步   GITHUB   frp 支持多种代理类型，为不同场景下的需求提供丰富的解决方案。\n         frp 采用 C/S 模式，将服务端部署在具有公网 IP 的机器上，客户端部署在内网或防火墙内的机器上，通过访问暴露在服务器上的端口，反向代理到处于内网的服务。 在此基础上，frp 支持 TCP, UDP, HTTP, HTTPS 等多种协议，提供了加密、压缩，身份认证，代理限速，负载均衡等众多能力。\n      下载 从 Github Release 页面下载最新版本。\n    欢迎参与贡献! 在 Github 上提交 Issue 和 Pull Request。\n 更多 …\n   交流 加入知识星球兴趣圈 frp 和开发者共同交流。\n 更多 …\n    ","categories":"","description":"","excerpt":" 简单、高效的内网穿透工具 起步   GITHUB   frp 支持多种代理类型，为不同场景下的需求提供丰富的解决方案。 …","ref":"/","tags":"","title":"frp"},{"body":" Welcome to FRP: A Fast Reverse Proxy! Learn More   GITHUB   frp helps you expose your service behind a firewall or NAT to the public internet.\n         frp supports multiple proxy types like TCP, UDP, HTTP, HTTPS, STCP, SUDP, XTCP, TCPMUX.\n      Download Download from Github Release.\n    Contributions welcome! We do a Issue and Pull Request contributions workflow on GitHub. New users are always welcome!\n Read more …\n    ","categories":"","description":"","excerpt":" Welcome to FRP: A Fast Reverse Proxy! Learn More   GITHUB   frp helps …","ref":"/en/","tags":"","title":"Goldydocs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"了解如何部署、使用 frp。\n","categories":"","description":"","excerpt":"了解如何部署、使用 frp。\n","ref":"/docs/","tags":"","title":"文档"},{"body":"v0.46.1  [fix] 服务端插件 NewWorkConn 请求没有设置正确的 op 名称。 [fix] QUIC stream 泄露。  v0.46.0  [new] frpc 增加 oidc_scope 配置。 [new] frpc 和 frps 之间的通信协议支持 quic。  v0.45.0  [improve] http group 的负载均衡调整为每一个请求都会以轮询的方式转发到 group 中的所有 frpc proxy。之前单个并发时会始终转发到同一个 proxy。  v0.44.0  [new] https2https 和 https2http 插件中，如果 plugin_key_path 和 plugin_crt_path 都为空，则使用自动创建的证书。 [new] frps dashboard 支持配置 TLS 证书。 [fix] 修复 XTCP 使用 IPv6 地址遇到错误的问题。  v0.43.0  [new] http 和 tcpmux 类型的 proxy 新增 route_by_http_user 参数，支持根据 HTTP Basic Auth user 来进行路由。 [new] http 类型的 proxy 支持 CONNECT method 的转发。 [new] tcpmux 类型新增 tcpmux_passthrough ，为 true 时，会透传 CONNECT 请求的内容。  v0.42.0  [new] frpc 支持指定配置目录，为每一个配置文件启动一个客户端实例。(注意这种模式下无法支持所有的功能) [fix] 修复环境变量中存在 = 号会导致值解析出错的问题。  v0.41.0  [new] 支持 go http pprof。 [improve] 底层 TCP keepalive 间隔默认设置为 2 小时。 [improve] sudp visitor 在需要时才发起和服务端的连接，避免 server 下线后频繁打印日志。  v0.40.0  [new] frpc 新增 dial_server_timeout ，支持配置连接服务端的超时时间。 [new] OIDC 支持配置额外的 EndpointParams。 [new] ServerPlugin 新增 CloseProxy 类型的 operation。 [improve] frpc 的重连时间间隔引入一些随机性。 [fix] 修复 tls_trusted_ca_file 未设置时，TLS server name 没有正确设置的问题。  v0.39.1  [fix] 修复 IPv6 地址解析出错的问题。  v0.39.0  [new] frpc 新增 connect_server_local_ip 支持指定连接 frps 时绑定指定的本地 IP。 [new] frpc 和 frps 新增 tcp_mux_keepalive_interval 参数支持配置 tcp_mux 的 keepalive 间隔，仅当 tcp_mux 为 true 时生效。配置此参数后，可以将 heartbeat_interval 设置为 -1，禁用应用层的心跳探测以减少流量消耗。(需要服务端也更新到最新版本)。 [improve] Server Plugin 的 Login Operation 增加 Client Address 字段。 [fix] /healthz API 移除鉴权。  v0.38.0  [new] 增加 /healthz API。 [new] frpc 增加 disable_custom_tls_first_byte ，当此参数为 true 时， frpc 通过 TLS 连接 frps 时不会发送一个自定义的字节，而是直接发送 TLS 内容。 [improve] 使用标准库 embed 包替换 statik。  v0.37.1  [fix] 修复 https2https 不可用的问题。 [fix] 修复 http_proxy HTTP 请求复用同一个连接会出现 context canceled 的问题。 [fix] 修复某些情况下 https 类型 proxy 获取 server name 出错的问题。  v0.37.0  [new] frpc 增加 verify 命令，检测配置文件是否有明显的错误， frpc verify -c ./frpc.ini 。 [new] frpc 配置文件支持 includes 语法，支持拆分 proxy 配置到多个文件或目录。 [new] Dashboard 支持 sudp 类型代理。 [fix] Dashboard 用户名密码默认为空。 [fix] 修复 protocol = kcp 时 login_fail_exit 无效的问题。  v0.36.2  [improve] Dashboard 支持在增加 URL Path 前缀的反向代理后被正常访问。 [fix] 修复 config 解析的一些错误逻辑。  v0.36.1  [fix] 修复 bind_udp_port 绑定端口错误的问题。  v0.36.0  [new] 新增 https2https 插件。 [new] frpc 新增 tls_server_name 参数。 [improve] 增加客户端由于网络连接错误时的重试频率。 [fix] 修复 xtcp 代理某些情况下会导致程序 panic 的问题。  v0.35.1  [fix] 减小 Release 二进制文件体积。  v0.35.0  [new] Server Plugin 支持 HTTPS 协议。 [fix] 修复 IPv6 地址解析异常的问题。 [fix] 修复 HTTP 类型代理转发 Websocket Connection Header 设置错误的问题。  v0.34.3  [new] 支持通过命令行参数启用 prometheus。  v0.34.2  [fix] 修复了 HTTP 类型代理，对于 Chunked 等流式数据传输延迟的问题。  v0.34.1  [new] http proxy 支持 ntlm 协议。 [new] 提供官方 docker 镜像。 [fix] 修复重连的 proxy 的统计数据过七天后会从 Dashboard 消失的问题。 [fix] 修复 TLS 证书验证出错的问题。  v0.34.0  [new] 支持设置 udp 包的大小，默认为 1500 字节。 [new] 支持配置 TLS 证书，支持双向认证。 [new] 新的 e2e 测试框架。 [fix] 修复 udp, sudp 类型的代理不支持压缩和加密的问题。 [change] 将调用 plugins 的顺序修改为固定顺序。  v0.33.0  [new] Server Plugin 增加 NewUserConn 接口。 [new] 新增 sudp 类型代理，支持以安全的方式转发 udp 端口。 [new] tcpmux 类型代理支持负载均衡。 [fix] 修复 frpc AuthenticateNewWorkConns 参数未生效的问题。 [fix] 修复一处并发导致的接受新连接时可能会 panic 的问题。  v0.32.1  [new] Server Plugin 增加 Ping 和 NewWorkConn 的接口。 [new] Server Plugin 在 http 请求 Query 中增加 apiVersion 和 op 字段。 [improve] 采用指数退避算法避免登录成功后立即断开连接的情况下的频繁重连。 [fix] 修复 frpc 在不断重连的情况下内存泄露的问题。  v0.32.0  [new] frps 支持 tls_only 参数，如果启用，服务端只接受 TLS 连接。 [new] 可选通过配置不返回创建 proxy 失败的具体信息。 [new] 支持 prometheus 监控。 [new] 支持可选 OIDC 身份验证。 [new] 新增 tcpmux 类型代理，通过 HTTP CONNECT 复用单一端口连接后端不同服务。 [fix] 修复限流配置在 Reload 时没有正确比对的问题。 [fix] 修复连接数统计不准确的问题。  v0.31.2  [fix] 修复 frpc 启动 proxy 失败时未释放端口的问题。  v0.31.1  [fix] 修复 proxy 中配置 meta 数据会 panic 的问题。  v0.31.0  [new] 新增服务端管理插件功能，支持扩展 frp 能力。 [improve] 优化 xtcp 在某些特殊情况下的成功率。  v0.30.0  [new] 支持单个 proxy 设置限流。 [new] 新增 https2http 插件，将内网 https 服务以 http 协议暴露出去。  v0.29.1  [fix] 修复 xtcp 启用 use_encryption 不能正常工作的问题。  v0.29.0  [new] 新增 disable_log_color 配置，可选关闭 console 日志颜色。 [new] plugin https2http 支持附加额外的 header。 [change] 修改代码结构，提供 Service 相关的 Go API。 [fix] 修复 max_pool_count 没有生效的问题。 [fix] 修复 proxy protocol IPv4 和 IPv6 判断错误的问题。  v0.28.2  [fix] 修复一处健康检查可能无法恢复的问题。  v0.28.1  [new] 更新部分第三方库版本。 [new] http 类型支持更多 upgrade 协议。  v0.28.0  [new] 负载均衡支持 HTTP 类型的代理。 [fix] 修复 login_fail_exit 为 false 时的连接泄露问题。  v0.27.1  [fix] 增加检测 TLS 连接时的超时机制。  v0.27.0  [new] Proxy Protocol 支持 plugin unix_domain_socket。 [new] HTTP 支持自定义 404 页面。  v0.26.0  [new] 增加 proxy protocol 支持。 [new] 增加 plugin https2http。 [fix] 修复 frpc 通过命令行模式启动 http/https 路由冲突的问题。  v0.25.3  [fix] 修复 tls_enable 为 true 时重连 panic 的问题。  v0.25.2  [change] 更新 kcp-go 的版本。 [fix] 修复一处健康检查连接未正常关闭的问题。  v0.25.1  [fix] 修复多级子域名匹配问题。 [fix] 修复 frps --log_file 不生效的问题。  v0.25.0  [new] frpc 支持通过 TLS 连接 frps。 [new] 提高 xtcp 连接建立的稳定性。 [fix] 修复 xtcp 某些情况下连接未释放的问题。  注意：xtcp 在该版本和之前的版本不兼容。\nv0.24.1  [fix] token 未设置时，通过 admin 界面上传配置导致配置文件被清空的问题。  v0.24.0  [new] frpc 增加 admin 管理界面。  v0.23.3  [fix] 修复 Reload 后没有保存配置的问题。  v0.23.2  [fix] 修复异常重连后导致客户端不能正常工作的问题。  v0.23.1  [fix] 修复 status api 错误。 [fix] 修复 reload 和 status 命令失败的错误。  v0.23.0  [new] 配置文件支持使用环境变量进行渲染。 [change] 取消 token 验证超时的检测。  v0.22.0  [new] proxy 支持健康检查，自动摘除失败的 proxy。 [fix] 修复一处 xtcp 连接异常导致的 panic 问题。 [fix] frpc 通过代理连接 frps 鉴权失败的问题。 [fix] 命令行模式配置成文件无效的问题。  v0.21.0  [new] frpc 支持通过 websocket 协议连接 frps。 [new] 支持设置 vhost http server 的超时时间。 [fix] 修复 stcp 和 xtcp 配置错误。  v0.20.0  [new] dashboard 增加 stcp 的统计数据。 [new] 支持多 proxy 的负载均衡，目前只支持 tcp 类型。 [new] 支持设置 http 请求中的 header。  v0.19.1  [change] frps dashboard ui 更新。 [improve] xtcp 在没有服务端和鉴权错误的情况下更快的返回错误，而不是等待超时。 [fix] 修复命令行启动 stcp 和 xtcp 缺少 bind_port 配置的问题。 [fix] 修复 http 类型的 proxy 在服务端未启用 vhost_http_port 会导致 panic 的问题。  v0.19.0  [new] frpc 支持通过 socks5 proxy 连接 frps。 [new] vhost_http_port 和 vhost_https_port 可以设置为和 bind_port 一样的端口，支持端口复用。 [new] Dashboard 总览页面增加一些参数显示。 [change] 部分 package 迁移到 golib 中，方便复用。  v0.18.0  [change] 从 smux 库替换为 yamux 库。  注意：该版本和之前的版本不兼容。\nv0.17.0  [new] 服务端 status 接口支持获取单个 proxy 的统计数据。 [new] frpc 支持配置指定的 dns 解析服务器。 [change] 更多的启动参数支持，便于不使用配置文件直接启动客户端。  v0.16.1  [fix] 修复统计数据当前连接数异常的情况。 [fix] 修复 udp proxy 连接没有正常关闭的问题。  v0.16.0  [new] 新的 plugin static_file，通过 http 接口对外提供文件访问服务。 [new] socks5 plugin 支持设置用户名密码。 [new] 配置文件支持范围端口映射。 [new] frps 可配置单个客户端最多允许使用的端口数量。  v0.15.1  [change] 默认 privilege_allow_ports 为 1 - 65535。 [fix] 重构后的 http 反向代理不支持 websocket。 [fix] Plugin http_proxy 无法正常工作的问题。  v0.15.0  [new] frpc 增加 status 命令用于查看本地 proxy 状态信息。 [new] remote_port 支持设置为 0，则由服务端随机绑定一个远程端口。 [change] frpc 的 –reload 命令修改为 reload。 [fix] HTTP 类型的 proxy 没有流量统计信息。 [fix] 修复 socks5 plugin 使用加密压缩功能会 panic 的问题。 [fix] 修复一处可能会导致连接不释放的问题。  v0.14.1  [improvement] 每一个 http 请求增加 X-Real-IP，不再增加 X-Forwarded-For。 [improvement] 优化 http 类型的 proxy 的稳定性。 [improvement] 优化 role 参数配置错误的提示信息。 [fix] 修复 kcp 绑定端口显示错误的问题。  v0.14.0  [new] 新增 xtcp(支持 udp 打洞内网直连) 类型。 [fix] 修复 frpc 默认配置文件名错误的问题。 #405  v0.13.0  [new] 新增 stcp(secret tcp) 类型。 [new] frpc 支持动态加载配置文件。 [new] 对于 http 类型的代理，每个连接的第一个请求附加上 X-Forwarded-For 和 X-Real-IP 的 header，用于传递用户真实 IP。 [new] 新增 socks5 plugin。 [new] frps 新增参数 proxy_bind_addr，指定代理在服务端绑定的 ip 地址。 [improvement] 优化使用 kcp 时退出程序时延迟断开连接的问题。 [fix] 修复 host_header_rewirte 功能出错的问题。 #248  v0.12.0  [new] 底层通信协议可选 kcp，在弱网环境下优化明显。 #99 [improvement] 对于 domain 不存在的情况返回 404 Not Found 页面。 #175 [fix] 修复启用加密压缩后，连接不能正常断开的问题。 #322 [fix] 修复启用加密压缩后，内存占用异常的问题。#345 [fix] 修复 http_proxy plugin 无法使用加密和压缩的问题。  v0.11.0  [new] 增加代理 unix域套接字 的 Plugin。 [new] 增加 http proxy Plugin。 [new] frpc 新增 login_fail_exit 配置项，如果为 false，则启动时连接服务器失败将不会退出，而是定期重连。 [new] frpc 新增 start 配置项，可以选择启用指定的 proxy，默认为空，表示全部。 [improvement] dashboard 自动清除 7天内没有使用的 proxy 的统计信息。 [improvement] dashboard 增加 frps 版本信息以及 proxy 最近一次启动和退出的时间信息。 [improvement] dashboard 启用 gzip，缩小页面体积。 [fix] 修复 frpc -v 失败的问题。 [fix] 修复 HTTP_PROXY 存在转义字符鉴权失败的问题。 #275 [fix] 修复 dashboard 鉴权错误的问题。 #339  v0.10.0  [new] 支持 TCP 多路复用。 [new] 重新设计的 Dashboard。 [improvement] 代码重构，协议变更，提高稳定性和性能。 [improvement] 内存优化。 [change] 压缩算法替换为 snappy。 [change] 配置文件部分参数命名变更。 [fix] 修复了一些已知的问题。  v0.9.3  [fix] 修复非特权模式不能配置二级域名的问题。 #220 [fix] 修改同名代理连接后导致前一个代理无法使用的问题。 #227 [fix] 修复一处连接池导致的 panic 问题。 #237  v0.9.2  [improvement] 减少默认的心跳间隔和超时时间。 [improvement] 心跳包间隔和超时时间改为可配置。 [fix] 修复一处由于 close nil channel 导致 frps panic 的问题。 #205 [fix] 修复 udp 类型的 proxy 重连失败的问题。 #209  v0.9.1  [new] 支持 url 路由。 [fix] 修复 subdomain 对于 https 类型不生效的问题。 [fix] 修复 ssh 启用了 pool_count 后无法正常连接的问题。 [fix] 修复一个可能导致 frpc 连接 frps 时一直无响应的问题。  v0.9.0  [new] UDP 协议支持。 [new] Dashboard 增加身份验证机制。 [new] http 服务支持身份验证，可在 frpc 端设置用户名密码。 [new] frpc 支持通过 http_proxy 连接 frps。 [new] http,https 服务支持泛域名。 [new] http 及 https 类型支持 subdomain 设置。 [new] 增加 Docker 支持。 [improvement] 支持设置身份验证的超时时间 authentication_timeout。 [fix] 修复连接池不生效的问题。 [fix] 修复多个客户端同时登录可能会导致 frps 异常退出的问题。  v0.8.1  [fix] 某些情况下 dashboard 状态显示不更新。 [fix] authToken 大于等于16字节会导致服务器端 panic。 [fix] 由于 beego.logs 更新导致的无法删除过期日志文件。  v0.8.0  [new] 新增 dashboard 界面，代理信息展示。 [new] server 端流量统计。 [new] 新增连接池，优化大量短连接服务的连接速度。 [new] 特权模式，支持配置允许使用的端口号范围。 [new] 新增 host-header-rewrite 配置项，可以根据需要修改 http 包的 header 中的 host 参数。 [improvement] 优化 gc，减少内存分配。 [improvement] 支持绑定 ipv6 地址。 [fix] 修复服务器端一建立连接就发送数据包时有一定几率会丢包的问题。  v0.7.0  [new] 支持 https 协议。 [new] 可选是否启用数据压缩。 [new] 新增特权模式，免 server 端配置启动代理。 [improvement] 优化数据传输，取消base64转码。 [fix] 修复 vhost_http_port 未指定时 frps 异常退出的问题。 交互协议与旧版本不兼容  v0.6.0  [new] 增加 reload 命令，支持动态加载配置文件。 [improvement] 优化 frpc 创建 tunnel 的步骤为异步操作，可承载更多的并发请求。 [fix] 修复 frpc 登录失败后的处理逻辑。 [fix] 修复同时有大量短连接时有一定几率出现的无法连接的错误。 [fix] 修复 windows 平台上一个连接出错的问题。  v0.5.0  [new] 针对http服务进行优化，支持虚拟主机和自定义域名绑定。 [change] 日志文件支持最大保存天数，默认为3天。 [fix] 修复连接中断后无法重新连接的错误。  v0.3.0  [new] 可以通过配置对frpc和frps之间通信内容进行加密处理。 [new] 新的身份认证机制，避免明文传输密码，提高安全性。 [change] 配置文件中 passwd 替换为 全局的 auth_token。 [improvement] 代码结构优化。 配置文件及协议与旧版本不兼容  v0.2.0  [new] 新增相关说明文档。 [new] frpc支持转发任意的 [ip:port]，默认为127.0.0.1。 [new] 增加命令行启动参数，可配置配置文件路径、日志保存路径、日志级别，查看版本号、帮助信息。 [new] 新增Dockerfile，增加对Docker的支持。 [change] 延长心跳发送间隔以及超时时间。  v0.1.0 正式发布的稳定可用版本。\n [new] 提供tcp层反向代理，用于穿透内网，对外提供ssh、http等服务。  ","categories":"","description":"","excerpt":"v0.46.1  [fix] 服务端插件 NewWorkConn 请求没有设置正确的 op 名称。 [fix] QUIC stream 泄 …","ref":"/release/","tags":"","title":"版本历史"}]