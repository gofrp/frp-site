[{"body":"LogConfig Field Type Description Required to string Log output file path. If set to console, logs will be printed to standard output. No level string Log level. Options are trace, debug, info, warn, error. Default level is info. No maxDays int Maximum days to retain log files, default is 3 days. No disablePrintColor bool Disable log colors in standard output. No WebServerConfig Field Type Description Required addr string webServer listening address, default is 127.0.0.1. No port int webServer listening port. Yes user string HTTP BasicAuth username. No password string HTTP BasicAuth password. No assetsDir string Static resource directory. Dashboard resources are packaged in the binary file by default. Use this parameter to specify custom static resources. No pprofEnable bool Enable Go HTTP pprof for application debugging. No tls TLSConfig TLS related configuration for Dashboard HTTPS. No TLSConfig Field Type Description Required certFile string TLS certificate file path. Yes keyFile string TLS key file path. Yes trustedCaFile string CA certificate file path. No serverName string TLS Server name. No QUICOptions Field Type Description Required keepalivePeriod int Default value is 10 seconds. No maxIdleTimeout int Default value is 30 seconds. No maxIncomingStreams int Default value is 100000. No PortsRange Field Type Description Required start int Starting port. No end int Ending port. No single int Single port. No HeaderOperations Field Type Description Required set map[string]string Set specified KV values in Header. No HTTPHeader Field Type Description Required name string Header name. Yes value string Header value. Yes ValueSource Field Type Description Required type string Data source type. Options are “file” and “exec”. Yes file FileSource File data source configuration, required when type is “file”. No exec ExecSource External command data source configuration, required when type is “exec”. Requires --allow-unsafe=TokenSourceExec flag at startup. No FileSource Field Type Description Required path string File path. Yes ExecSource Field Type Description Required command string Path to the command to execute. Yes args []string List of command arguments. No env []ExecEnvVar Additional environment variables. No ExecEnvVar Field Type Description Required name string Environment variable name. Yes value string Environment variable value. Yes NatTraversalConfig Field Type Description Required disableAssistedAddrs bool Disable assisted connections using local network interface addresses. When enabled, only uses STUN-discovered public addresses for NAT hole punching, avoiding potentially slow local network interfaces (e.g., VPN). Default is false. No ","categories":"","description":"Common configuration structures.\n","excerpt":"Common configuration structures.\n","ref":"/en/docs/reference/common/","tags":"","title":"Common Configuration"},{"body":"","categories":"","description":"Learn about some common features of frp.\n","excerpt":"Learn about some common features of frp.\n","ref":"/en/docs/features/common/","tags":"","title":"Common Features"},{"body":"Encryption and Compression Note: When TLS is enabled between frpc and frps, traffic will be globally encrypted, and encryption on individual proxies is no longer needed. This is enabled by default in newer versions.\nEach proxy can choose whether to enable encryption and compression features.\nThe encryption algorithm uses aes-128-cfb, and the compression algorithm uses snappy.\nSpecify in each proxy’s configuration using the following parameters:\n[[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 transport.useEncryption = true transport.useCompression = true By setting transport.useEncryption = true, the communication content between frpc and frps will be encrypted during transmission, effectively preventing transmission content from being intercepted.\nIf the transmitted packet length is long, setting transport.useCompression = true to compress the transmission content can effectively reduce network traffic between frpc and frps, speed up traffic forwarding, but will consume some additional CPU resources.\nTCP Multiplexing The connection between client and server supports multiplexing, no longer requiring a connection to be created for each user request, reducing connection establishment latency and avoiding occupying large numbers of file descriptors, allowing frp to handle higher concurrency.\nThis feature is enabled by default. To disable it, configure in both frps.toml and frpc.toml. This configuration must be consistent between server and client:\n# In both frps.toml and frpc.toml transport.tcpMux = false Connection Pool By default, frps will only request frpc to actively establish a connection with the backend service after a user request establishes a connection. When connection pooling is enabled for a specified proxy, frp will pre-establish a specified number of connections with the backend service. Each time a user request is received, a connection will be taken from the connection pool and associated with the user connection, avoiding the time of waiting to establish a connection with the backend service and passing control information between frpc and frps.\nThis feature is suitable for scenarios with a large number of short connections.\nNote: When TCP multiplexing is enabled, the improvement from connection pooling is limited and generally not needed in common scenarios.\nFirst, you can set the upper limit of connection pools that each proxy can create in frps.toml to avoid occupying large amounts of resources. Client settings exceeding this configuration will be adjusted to the current value:\n# frps.toml transport.maxPoolCount = 5 Enable connection pooling for the client in frpc.toml, specifying the number of pre-created connections:\n# frpc.toml transport.poolCount = 1 KCP Protocol Support The underlying communication protocol supports selecting KCP protocol. Compared to TCP, transmission efficiency is significantly improved in weak network environments, but there will be some additional traffic consumption.\nEnable KCP protocol support:\nEnable KCP protocol support in frps.toml, specifying a UDP port for receiving client requests:\n# frps.toml bindPort = 7000 # kcp binds to UDP port, can be the same as bindPort kcpBindPort = 7000 Specify the protocol type to use in frpc.toml, other proxy configurations don’t need to change:\n# frpc.toml serverAddr = \"x.x.x.x\" # serverPort specifies frps's kcpBindPort serverPort = 7000 transport.protocol = \"kcp\" QUIC Protocol Support The underlying communication protocol supports selecting QUIC protocol, which uses UDP transmission at the bottom layer, solving some problems with TCP, with higher transmission efficiency and lower connection latency.\nEnable QUIC protocol support:\nEnable QUIC protocol support in frps.toml, specifying a UDP port for receiving client requests:\n# frps.toml bindPort = 7000 # QUIC binds to UDP port, can be the same as bindPort quicBindPort = 7000 Specify the protocol type to use in frpc.toml, other proxy configurations don’t need to change:\n# frpc.toml serverAddr = \"x.x.x.x\" # serverPort specifies frps's quicBindPort serverPort = 7000 transport.protocol = \"quic\" ","categories":"","description":"","excerpt":"Encryption and Compression Note: When TLS is enabled between frpc and …","ref":"/en/docs/features/common/network/network/","tags":"","title":"Communication Security and Optimization"},{"body":"What is frp? frp is a high-performance reverse proxy application that focuses on intranet penetration. It supports multiple protocols including TCP, UDP, HTTP, HTTPS, and features P2P communication capabilities. Using frp, you can securely and conveniently expose intranet services to the public network through nodes with public IP addresses.\nWhy choose frp? By deploying the frp server on nodes with public IP addresses, you can easily penetrate intranet services to the public network and enjoy the following professional features:\nMultiple protocol support: Client-server communication supports TCP, QUIC, KCP, Websocket and other protocols. TCP connection stream multiplexing: Carry multiple requests on a single connection, reducing connection establishment time and request latency. Load balancing between proxy groups. Port multiplexing: Multiple services can be exposed through the same server port. P2P communication: Traffic does not need to be relayed through the server, making full use of bandwidth resources. Client plugins: Provides multiple natively supported client plugins, such as static file viewing, HTTPS/HTTP protocol conversion, HTTP, SOCKS5 proxy, etc., to meet various needs. Server plugin system: Highly extensible server plugin system, convenient for feature expansion according to your own needs. User-friendly UI pages: Provides user interfaces for both server and client, making configuration and monitoring more convenient. What’s next? Setup: Learn how to install frp. Examples: Understand different application scenarios of frp through simple examples. ","categories":"","description":"Some overview to help you quickly understand frp.\n","excerpt":"Some overview to help you quickly understand frp.\n","ref":"/en/docs/overview/","tags":"","title":"Overview"},{"body":"On Linux systems, using systemd can conveniently control the start, stop, background running configuration, and boot auto-start of the frps server.\nHere are the specific operation steps:\nInstall systemd\nIf systemd is not yet installed on your Linux server, you can use package managers like yum (for CentOS/RHEL) or apt (for Debian/Ubuntu) to install it:\n# Install systemd using yum (CentOS/RHEL) yum install systemd # Install systemd using apt (Debian/Ubuntu) apt install systemd Create frps.service file\nUse a text editor (like vim) to create a frps.service file in the /etc/systemd/system directory to configure the frps service.\n$ sudo vim /etc/systemd/system/frps.service Write the content:\n[Unit] # Service name, customizable Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # Command to start frps, modify to your frps installation path ExecStart = /path/to/frps -c /path/to/frps.toml [Install] WantedBy = multi-user.target Use systemd commands to manage frps service\n# Start frp sudo systemctl start frps # Stop frp sudo systemctl stop frps # Restart frp sudo systemctl restart frps # Check frp status sudo systemctl status frps Set frps to auto-start on boot\nsudo systemctl enable frps By following the above steps, you can easily use systemd to manage the frps service, achieving start, stop, automatic running, and boot auto-start. Make sure to replace paths and configuration file names to match your actual installation.\n","categories":"","description":"This example demonstrates how to use systemd to manage frps service on Linux systems, including starting, stopping, configuring background running, and setting auto-start on boot.\n","excerpt":"This example demonstrates how to use systemd to manage frps service on …","ref":"/en/docs/setup/systemd/","tags":"","title":"Using systemd"},{"body":"在 Linux 系统下，使用 systemd 可以方便地控制 frps 服务端的启动、停止、配置后台运行以及开机自启动。\n以下是具体的操作步骤：\n安装 systemd\n如果您的 Linux 服务器上尚未安装 systemd，可以使用包管理器如 yum（适用于 CentOS/RHEL）或 apt（适用于 Debian/Ubuntu）来安装它：\n# 使用 yum 安装 systemd（CentOS/RHEL） yum install systemd # 使用 apt 安装 systemd（Debian/Ubuntu） apt install systemd 创建 frps.service 文件\n使用文本编辑器 (如 vim) 在 /etc/systemd/system 目录下创建一个 frps.service 文件，用于配置 frps 服务。\n$ sudo vim /etc/systemd/system/frps.service 写入内容\n[Unit] # 服务名称，可自定义 Description = frp server After = network.target syslog.target Wants = network.target [Service] Type = simple # 启动frps的命令，需修改为您的frps的安装路径 ExecStart = /path/to/frps -c /path/to/frps.toml [Install] WantedBy = multi-user.target 使用 systemd 命令管理 frps 服务\n# 启动frp sudo systemctl start frps # 停止frp sudo systemctl stop frps # 重启frp sudo systemctl restart frps # 查看frp状态 sudo systemctl status frps 设置 frps 开机自启动\nsudo systemctl enable frps 通过遵循上述步骤，您可以轻松地使用 systemd 来管理 frps 服务，实现启动、停止、自动运行和开机自启动。确保替换路径和配置文件名称以匹配您的实际安装。\n","categories":"","description":"此示例演示如何在 Linux 系统下使用 systemd 来管理 frps 服务，包括启动、停止、配置后台运行和设置开机自启动。\n","excerpt":"此示例演示如何在 Linux 系统下使用 systemd 来管理 frps 服务，包括启动、停止、配置后台运行和设置开机自启动。\n","ref":"/zh-cn/docs/setup/systemd/","tags":"","title":"使用 systemd"},{"body":"frp 是什么？ frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，您可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。\n为什么选择 frp？ 通过在具有公网 IP 的节点上部署 frp 服务端，您可以轻松地将内网服务穿透到公网，并享受以下专业特性：\n多种协议支持：客户端服务端通信支持 TCP、QUIC、KCP 和 Websocket 等多种协议。 TCP 连接流式复用：在单个连接上承载多个请求，减少连接建立时间，降低请求延迟。 代理组间的负载均衡。 端口复用：多个服务可以通过同一个服务端端口暴露。 P2P 通信：流量不必经过服务器中转，充分利用带宽资源。 客户端插件：提供多个原生支持的客户端插件，如静态文件查看、HTTPS/HTTP 协议转换、HTTP、SOCKS5 代理等，以便满足各种需求。 服务端插件系统：高度可扩展的服务端插件系统，便于根据自身需求进行功能扩展。 用户友好的 UI 页面：提供服务端和客户端的用户界面，使配置和监控变得更加方便。 下一步？ 安装：了解如何安装 frp。 示例：通过简单示例了解 frp 的不同应用场景。 ","categories":"","description":"一些概述，便于您快速的了解 frp。\n","excerpt":"一些概述，便于您快速的了解 frp。\n","ref":"/zh-cn/docs/overview/","tags":"","title":"概览"},{"body":"加密与压缩 注: 当 frpc 和 frps 之间启用了 TLS 之后，流量会被全局加密，不再需要配置单个代理上的加密，新版本中已经默认启用。\n每一个代理都可以选择是否启用加密和压缩的功能。\n加密算法采用 aes-128-cfb，压缩算法采用 snappy。\n在每一个代理的配置中使用如下参数指定：\n[[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 transport.useEncryption = true transport.useCompression = true 通过设置 transport.useEncryption = true，将 frpc 与 frps 之间的通信内容加密传输，将会有效防止传输内容被截取。\n如果传输的报文长度较长，通过设置 transport.useCompression = true 对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 CPU 资源。\nTCP 多路复用 客户端和服务器端之间的连接支持多路复用，不再需要为每一个用户请求创建一个连接，使连接建立的延迟降低，并且避免了大量文件描述符的占用，使 frp 可以承载更高的并发数。\n该功能默认启用，如需关闭，可以在 frps.toml 和 frpc.toml 中配置，该配置项在服务端和客户端必须一致：\n# frps.toml 和 frpc.toml 中 transport.tcpMux = false 连接池 默认情况下，当用户请求建立连接后，frps 才会请求 frpc 主动与后端服务建立一个连接。当为指定的代理启用连接池后，frp 会预先和后端服务建立起指定数量的连接，每次接收到用户请求后，会从连接池中取出一个连接和用户连接关联起来，避免了等待与后端服务建立连接以及 frpc 和 frps 之间传递控制信息的时间。\n这一功能适合有大量短连接请求时开启。\n注: 当 TCP 多路复用启用后，连接池的提升有限，一般场景下无需关心。\n首先可以在 frps.toml 中设置每个代理可以创建的连接池上限，避免大量资源占用，客户端设置超过此配置后会被调整到当前值：\n# frps.toml transport.maxPoolCount = 5 在 frpc.toml 中为客户端启用连接池，指定预创建连接的数量：\n# frpc.toml transport.poolCount = 1 支持 KCP 协议 底层通信协议支持选择 KCP 协议，相比于 TCP，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。\n开启 KCP 协议支持：\n在 frps.toml 中启用 KCP 协议支持，指定一个 UDP 端口用于接收客户端请求：\n# frps.toml bindPort = 7000 # kcp 绑定的是 UDP 端口，可以和 bindPort 一样 kcpBindPort = 7000 在 frpc.toml 指定需要使用的协议类型，其他代理配置不需要变更：\n# frpc.toml serverAddr = \"x.x.x.x\" # serverPort 指定为 frps 的 kcpBindPort serverPort = 7000 transport.protocol = \"kcp\" 支持 QUIC 协议 底层通信协议支持选择 QUIC 协议，底层采用 UDP 传输，解决了 TCP 上的一些问题，传输效率更高，连接延迟低。\n开启 QUIC 协议支持：\n在 frps.toml 中启用 QUIC 协议支持，指定一个 UDP 端口用于接收客户端请求：\n# frps.toml bindPort = 7000 # QUIC 绑定的是 UDP 端口，可以和 bindPort 一样 quicBindPort = 7000 在 frpc.toml 指定需要使用的协议类型，其他代理配置不需要变更：\n# frpc.toml serverAddr = \"x.x.x.x\" # serverPort 指定为 frps 的 quicBindPort serverPort = 7000 transport.protocol = \"quic\" ","categories":"","description":"","excerpt":"加密与压缩 注: 当 frpc 和 frps 之间启用了 TLS 之后，流量会被全局加密，不再需要配置单个代理上的加密，新版本中已经默认启 …","ref":"/zh-cn/docs/features/common/network/network/","tags":"","title":"通信安全及优化"},{"body":"","categories":"","description":"了解 frp 的一些通用功能。\n","excerpt":"了解 frp 的一些通用功能。\n","ref":"/zh-cn/docs/features/common/","tags":"","title":"通用功能"},{"body":"LogConfig Field Type Description Required to string 日志输出文件路径，如果为 console，则会将日志打印在标准输出中。 No level string 日志级别，可选值为 trace, debug, info, warn, error，默认级别为 info。 No maxDays int 日志文件最多保留天数，默认为 3 天。 No disablePrintColor bool 禁用标准输出中的日志颜色。 No WebServerConfig Field Type Description Required addr string webServer 监听地址，默认为 127.0.0.1。 No port int webServer 监听端口。 Yes user string HTTP BasicAuth 用户名。 No password string HTTP BasicAuth 密码。 No assetsDir string 静态资源目录，Dashboard 使用的资源默认打包在二进制文件中，通过指定此参数使用自定义的静态资源。 No pprofEnable bool 启动 Go HTTP pprof，用于应用调试。 No tls TLSConfig Dashboard 启用 HTTPS 的 TLS 相关配置。 No TLSConfig Field Type Description Required certFile string TLS 证书文件路径。 Yes keyFile string TLS 密钥文件路径。 Yes trustedCaFile string CA 证书文件路径。 No serverName string TLS Server 名称。 No QUICOptions Field Type Description Required keepalivePeriod int 默认值为 10 秒。 No maxIdleTimeout int 默认值为 30 秒。 No maxIncomingStreams int 默认值为 100000。 No PortsRange Field Type Description Required start int 起始端口。 No end int 终止端口。 No single int 单一端口。 No HeaderOperations Field Type Description Required set map[string]string 在 Header 中设置指定的 KV 值。 No HTTPHeader Field Type Description Required name string Header 名称。 Yes value string Header 值。 Yes ValueSource Field Type Description Required type string 数据源类型，可选值为 “file” 和 “exec”。 Yes file FileSource 文件数据源配置，当 type 为 “file” 时必填。 No exec ExecSource 外部命令数据源配置，当 type 为 “exec” 时必填。需要启动时添加 --allow-unsafe=TokenSourceExec 参数。 No FileSource Field Type Description Required path string 文件路径。 Yes ExecSource Field Type Description Required command string 要执行的命令路径。 Yes args []string 命令参数列表。 No env []ExecEnvVar 额外的环境变量。 No ExecEnvVar Field Type Description Required name string 环境变量名称。 Yes value string 环境变量值。 Yes NatTraversalConfig Field Type Description Required disableAssistedAddrs bool 禁用本地网络接口地址的辅助连接。当启用时，仅使用通过 STUN 发现的公网地址进行 NAT 打洞，避免使用可能较慢的本地网络接口（如 VPN）。默认为 false。 No ","categories":"","description":"通用配置结构。\n","excerpt":"通用配置结构。\n","ref":"/zh-cn/docs/reference/common/","tags":"","title":"通用配置"},{"body":"transport.useEncryption and STCP functions can effectively prevent traffic content from being stolen during communication, but cannot determine whether the other party’s identity is legitimate, posing a risk of man-in-the-middle attacks. For this reason, frp supports traffic encryption between frpc and frps through TLS protocol, and supports client or server unidirectional verification, bidirectional verification, and other functions.\nWhen transport.tls.force = true in frps.toml, it means the server only accepts TLS connection clients, which is also a prerequisite for frps to verify frpc identity. If the content of transport.tls.trustedCaFile in frps.toml is valid, then transport.tls.force = true will be enabled by default.\nNote: After enabling this function, except for xtcp, you don’t need to set use_encryption for duplicate encryption\nTLS Default Enable Method Starting from v0.50.0, the default value of transport.tls.enable will be true, enabling TLS protocol encryption by default.\nIf the frps side has no certificate configured, it will use a randomly generated certificate to encrypt traffic.\nBy default, frpc enables TLS encryption function but does not verify frps’s certificate.\nfrpc Unidirectional Verification of frps Identity # frpc.toml transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" # frps.toml transport.tls.certFile = \"/to/cert/path/server.crt\" transport.tls.keyFile = \"/to/key/path/server.key\" frpc needs to additionally load the ca certificate, and frps needs to additionally specify TLS configuration. frpc unidirectionally verifies frps’s identity through the ca certificate. This requires that frps’s server.crt is legitimate for frpc’s ca.\nLegitimate: If the certificate is issued by ca, or the certificate is in ca’s trust chain, then it is considered: the certificate is legitimate for ca.\nfrps Unidirectional Verification of frpc Identity # frpc.toml transport.tls.certFile = \"/to/cert/path/client.crt\" transport.tls.keyFile = \"/to/key/path/client.key\" # frps.toml transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" frpc needs to additionally load TLS configuration, and frps needs to additionally load the ca certificate. frps unidirectionally verifies frpc’s identity through the ca certificate. This requires that frpc’s client.crt is legitimate for frps’s ca.\nBidirectional Verification # frpc.toml transport.tls.certFile = \"/to/cert/path/client.crt\" transport.tls.keyFile = \"/to/key/path/client.key\" transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" # frps.toml transport.tls.certFile = \"/to/cert/path/server.crt\" transport.tls.keyFile = \"/to/key/path/server.key\" transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" Bidirectional verification means frpc and frps verify each other’s identity through local ca certificates. Theoretically, frpc and frps can have different ca certificates, as long as they can verify each other’s identity.\nOpenSSL Certificate Generation Example x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0\nIf the above error occurs, it’s because go 1.15 version started deprecating CommonName, so SAN certificates are recommended.\nBelow is a simple example of how to generate ca and SAN certificates for both parties using openssl.\nPrepare the default OpenSSL configuration file in the current directory. This configuration file is usually located at /etc/pki/tls/openssl.cnf on linux systems and /System/Library/OpenSSL/openssl.cnf on mac systems.\nIf it exists, copy it directly to the current directory, for example cp /etc/pki/tls/openssl.cnf ./my-openssl.cnf. If it doesn’t exist, you can use the following command to create it.\ncat \u003e my-openssl.cnf \u003c\u003c EOF [ ca ] default_ca = CA_default [ CA_default ] x509_extensions = usr_cert [ req ] default_bits = 2048 default_md = sha256 default_keyfile = privkey.pem distinguished_name = req_distinguished_name attributes = req_attributes x509_extensions = v3_ca string_mask = utf8only [ req_distinguished_name ] [ req_attributes ] [ usr_cert ] basicConstraints = CA:FALSE nsComment = \"OpenSSL Generated Certificate\" subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer [ v3_ca ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = CA:true EOF Generate default ca:\nopenssl genrsa -out ca.key 2048 openssl req -x509 -new -nodes -key ca.key -subj \"/CN=example.ca.com\" -days 5000 -out ca.crt Generate frps certificate:\nopenssl genrsa -out server.key 2048 openssl req -new -sha256 -key server.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\")) \\ -out server.csr openssl x509 -req -days 365 -sha256 \\ -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\") \\ -out server.crt Generate frpc certificate:\nopenssl genrsa -out client.key 2048 openssl req -new -sha256 -key client.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:client.com,DNS:example.client.com\")) \\ -out client.csr openssl x509 -req -days 365 -sha256 \\ -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:client.com,DNS:example.client.com\") \\ -out client.crt In this example, both server.crt and client.crt are issued by the default ca, so they are legitimate for the default ca.\n","categories":"","description":"","excerpt":"transport.useEncryption and STCP functions can effectively prevent …","ref":"/en/docs/features/common/network/network-tls/","tags":"","title":"Custom TLS Protocol Encryption"},{"body":"Modify Host Header Normally, frp will not modify any forwarded data. However, some backend services will display different websites based on the Host field in HTTP request headers, such as nginx’s virtual host service. Enabling the Host Header modification feature can dynamically modify the Host field in HTTP requests. Note that this feature is only available for HTTP type proxies.\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] hostHeaderRewrite = \"dev.yourdomain.com\" The original Host field test.yourdomain.com in the HTTP request will be replaced with dev.yourdomain.com when forwarded to the backend service.\nSet Regular Headers For HTTP type proxies, you can set Header parameters that are dynamically added during forwarding.\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] hostHeaderRewrite = \"dev.yourdomain.com\" requestHeaders.set.x-from-where = \"frp\" responseHeaders.set.foo = \"bar\" According to the above configuration, x-from-where: frp will be added to the request Header, and foo: bar will be added to the response Header.\n","categories":"","description":"","excerpt":"Modify Host Header Normally, frp will not modify any forwarded data. …","ref":"/en/docs/features/http-https/header/","tags":"","title":"Modify HTTP Request Header"},{"body":"ServerConfig Field Type Description Required auth AuthServerConfig Authentication configuration. No bindAddr string Server listening address for receiving frpc connections, default listens on 0.0.0.0. No bindPort int Server listening port, default value is 7000. No kcpBindPort int Server listening port for KCP protocol, used to receive frpc connections configured to use KCP protocol. No quicBindPort int Server listening port for QUIC protocol, used to receive frpc connections configured to use QUIC protocol. No proxyBindAddr string Proxy listening address, can make proxies listen on different network interface addresses, same as bindAddr by default. No vhostHTTPPort int Listening port for HTTP type proxies, must be enabled to support HTTP type proxies. No vhostHTTPTimeout int ResponseHeader timeout for HTTP type proxies on the server side, default is 60s. No vhostHTTPSPort int Listening port for HTTPS type proxies, must be enabled to support HTTPS type proxies. No tcpmuxHTTPConnectPort int Listening port for tcpmux type proxies with httpconnect multiplexer. No tcpmuxPassthrough bool Whether to pass through CONNECT requests for tcpmux type proxies. No subDomainHost string Subdomain suffix. No custom404Page string Custom 404 error page address. No sshTunnelGateway SSHTunnelGateway SSH tunnel gateway configuration. No webServer WebServerConfig Server Dashboard configuration. No enablePrometheus bool Whether to provide Prometheus monitoring interface, will only take effect when webServer is also enabled. No log LogConfig Log configuration. No transport ServerTransportConfig Network layer configuration. No detailedErrorsToClient bool Server returns detailed error information to client, default is true. No maxPortsPerClient int Limit the maximum number of simultaneous proxies for a single client, default is unlimited. No userConnTimeout int Timeout for waiting for client response after user establishes connection, in seconds, default is 10 seconds. No udpPacketSize int Maximum packet length supported when proxying UDP services, default is 1500. Server and client values need to be consistent. No natholeAnalysisDataReserveHours int Retention time for hole punching strategy data, default is 168 hours, i.e. 7 days. No allowPorts []PortsRange Server ports allowed for proxy binding. No httpPlugins []HTTPPluginOptions Server HTTP plugin configuration. No AuthServerConfig Field Type Description Required method string Authentication method. Options are token or oidc, default is token. No additionalScopes []string Additional scope for authentication information. Options are HeartBeats and NewWorkConns No token string Effective when method is token. Client needs to set the same value to pass authentication. Mutually exclusive with tokenSource field. No tokenSource ValueSource Configuration for loading token from file. Mutually exclusive with token field. No oidc AuthOIDCServerConfig OIDC authentication configuration. No AuthOIDCServerConfig Field Type Description Required issuer string No audience string No skipExpiryCheck bool No skipIssuerCheck bool No ServerTransportConfig Field Type Description Required tcpMuxKeepaliveInterval int Heartbeat check interval time for tcp mux, in seconds. No tcpKeepalive int Keepalive interval time for underlying TCP connection with client, in seconds. Configure as negative number to disable. No maxPoolCount int Maximum connection pool size allowed for clients. If client configured value is greater than this value, it will be forcibly modified to the maximum value, default is 5. No heartbeatTimeout int Timeout for heartbeat connection between server and client, in seconds, default is 90 seconds. No quic QUICOptions QUIC protocol configuration parameters. No tls TLSServerConfig Server TLS protocol configuration. No TLSServerConfig Field Type Description Required force bool Whether to only accept client connections with TLS enabled. No TLSConfig TLS protocol configuration, embedded structure. No HTTPPluginOptions Field Type Description Required name string Plugin name. Yes addr string Plugin interface address. Yes path string Plugin interface path. Yes ops []string List of operations that the plugin needs to take effect. For specific optional values, please refer to the server plugin documentation. Yes tlsVerify bool When plugin address is HTTPS protocol, whether to verify the plugin’s TLS certificate, default is not to verify. No SSHTunnelGateway Field Type Description Required bindPort int SSH server listening port. YES privateKeyFile string SSH server private key file path. If empty, frps will read the private key file under autoGenPrivateKeyPath. No autoGenPrivateKeyPath string Private key file automatic generation path, default is ./.autogen_ssh_key. If the file does not exist or is empty, frps will automatically generate an RSA private key file and store it at this path. No authorizedKeysFile string SSH client authorized key file path. If empty, SSH client authentication will not be performed. Non-empty can implement SSH passwordless login authentication. No ","categories":"","description":"Detailed configuration description for frp server.\n","excerpt":"Detailed configuration description for frp server.\n","ref":"/en/docs/reference/server-configures/","tags":"","title":"Server Configuration"},{"body":" frp is written in Go and supports cross-platform deployment. You only need to download the binary file suitable for your platform to execute it, without additional dependencies.\nSystem Requirements Since it’s written in Go, the system requirements are consistent with the latest Go language requirements for systems and platforms. Please refer to Golang System requirements for details.\nDownload You can download the latest version of client and server binary files from the GitHub Release page. All files are packaged in a compressed archive, which also includes a complete configuration parameter documentation.\nDeployment Extract the downloaded compressed archive. Copy frpc to the machine where the intranet service is located. Copy frps to the machine with a public IP address, and place them in any directory. Start Using! Write configuration files. Currently supported file formats include TOML/YAML/JSON. The old INI format is still supported but is no longer recommended. Start the server using the following command: ./frps -c ./frps.toml. Start the client using the following command: ./frpc -c ./frpc.toml. If you need to run in the background for a long time, it is recommended to combine with other tools such as systemd and supervisor. If you are a Windows user, you need to execute the same commands in the command prompt.\nFor information on how to write configuration files, please refer to the content in the Examples section.\nFor complete configuration item descriptions, please refer to the content in Reference.\n","categories":"","description":"Instructions on how to install frp.\n","excerpt":"Instructions on how to install frp.\n","ref":"/en/docs/setup/","tags":"","title":"Setup"},{"body":"TCP and UDP are the two most basic proxy types in frp, used to proxy services listening on TCP and UDP ports.\nTCP Proxy [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 UDP Proxy [[proxies]] name = \"dns\" type = \"udp\" localIP = \"127.0.0.1\" localPort = 53 remotePort = 6000 Specify the proxy type through type.\nfrp will listen on the corresponding remote port on the server where frps is located for the local service port, associate the connections received by the remote port with the local service port, and transparently forward traffic, thereby enabling users to access internal services from outside.\n","categories":"","description":"Learn about frp `TCP`, `UDP` type proxies.\n","excerpt":"Learn about frp `TCP`, `UDP` type proxies.\n","ref":"/en/docs/features/tcp-udp/","tags":"","title":"TCP \u0026 UDP"},{"body":"TCP 和 UDP 是 frp 中两种最基础的代理类型，用于代理监听在 TCP 和 UDP 端口的服务。\nTCP 代理 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 UDP 代理 [[proxies]] name = \"dns\" type = \"udp\" localIP = \"127.0.0.1\" localPort = 53 remotePort = 6000 通过 type 指定代理类型。\nfrp 会为本地服务的端口，在 frps 所在的服务端监听对应的远程端口，将远程端口接收到的连接和本地服务的端口关联，透传流量，从而实现让用户在外部访问到内部服务。\n","categories":"","description":"了解 frp `TCP`, `UDP` 类型的代理。\n","excerpt":"了解 frp `TCP`, `UDP` 类型的代理。\n","ref":"/zh-cn/docs/features/tcp-udp/","tags":"","title":"TCP \u0026 UDP"},{"body":"修改 Host Header 通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 HTTP 请求 header 中的 Host 字段来展现不同的网站，例如 nginx 的虚拟主机服务，启用 Host Header 的修改功能可以动态修改 HTTP 请求中的 Host 字段。需要注意的是，该功能仅限于 HTTP 类型的代理。\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] hostHeaderRewrite = \"dev.yourdomain.com\" 原来 HTTP 请求中的 Host 字段 test.yourdomain.com 转发到后端服务时会被替换为 dev.yourdomain.com。\n设置普通 Header 对于类型为 HTTP 的代理，可以设置在转发中动态添加的 Header 参数\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] hostHeaderRewrite = \"dev.yourdomain.com\" requestHeaders.set.x-from-where = \"frp\" responseHeaders.set.foo = \"bar\" 根据如上的配置，会在请求的 Header 中加上 x-from-where: frp，在响应的 Header 中加上 foo: bar。\n","categories":"","description":"","excerpt":"修改 Host Header 通常情况下 frp 不会修改转发的任何数据。但有一些后端服务会根据 HTTP 请求 header …","ref":"/zh-cn/docs/features/http-https/header/","tags":"","title":"修改 HTTP 请求 Header"},{"body":" frp 采用 Go 语言编写，支持跨平台，只需下载适用于您平台的二进制文件即可执行，无需额外依赖。\n系统需求 由于采用 Go 语言编写，因此系统需求与最新的 Go 语言对系统和平台的要求一致，具体请参考 Golang System requirements。\n下载 您可以从 GitHub 的 Release 页面中下载最新版本的客户端和服务器二进制文件。所有文件都打包在一个压缩包中，还包含了一份完整的配置参数说明。\n部署 解压下载的压缩包。 将 frpc 复制到内网服务所在的机器上。 将 frps 复制到拥有公网 IP 地址的机器上，并将它们放在任意目录。 开始使用！ 编写配置文件，目前支持的文件格式包括 TOML/YAML/JSON，旧的 INI 格式仍然支持，但已经不再推荐。 使用以下命令启动服务器：./frps -c ./frps.toml。 使用以下命令启动客户端：./frpc -c ./frpc.toml。 如果需要在后台长期运行，建议结合其他工具，如 systemd 和 supervisor。 如果您是 Windows 用户，需要在命令提示符中执行相同的命令。\n有关如何编写配置文件，请参考 示例 部分中的内容。\n完整的配置项说明，请参考 Reference 中的内容。\n","categories":"","description":"关于如何安装 frp 的说明。\n","excerpt":"关于如何安装 frp 的说明。\n","ref":"/zh-cn/docs/setup/","tags":"","title":"安装"},{"body":"ServerConfig Field Type Description Required auth AuthServerConfig 鉴权配置。 No bindAddr string 服务端监听地址，用于接收 frpc 的连接，默认监听 0.0.0.0。 No bindPort int 服务端监听端口，默认值为 7000。 No kcpBindPort int 服务端监听 KCP 协议端口，用于接收配置了使用 KCP 协议的 frpc 连接。 No quicBindPort int 服务端监听 QUIC 协议端口，用于接收配置了使用 QUIC 协议的 frpc 连接。 No proxyBindAddr string 代理监听地址，可以使代理监听在不同的网卡地址，默认情况下同 bindAddr。 No vhostHTTPPort int HTTP 类型代理监听的端口，启用后才能支持 HTTP 类型的代理。 No vhostHTTPTimeout int HTTP 类型代理在服务端的 ResponseHeader 超时时间，默认为 60s。 No vhostHTTPSPort int HTTPS 类型代理监听的端口，启用后才能支持 HTTPS 类型的代理。 No tcpmuxHTTPConnectPort int tcpmux 类型且复用器为 httpconnect 的代理监听的端口。 No tcpmuxPassthrough bool 对于 tcpmux 类型的代理是否透传 CONNECT 请求。 No subDomainHost string 二级域名后缀。 No custom404Page string 自定义 404 错误页面地址。 No sshTunnelGateway SSHTunnelGateway ssh 隧道网关配置。 No webServer WebServerConfig 服务端 Dashboard 配置。 No enablePrometheus bool 是否提供 Prometheus 监控接口，需要同时启用了 webServer 后才会生效。 No log LogConfig 日志配置。 No transport ServerTransportConfig 网络层配置。 No detailedErrorsToClient bool 服务端返回详细错误信息给客户端，默认为 true。 No maxPortsPerClient int 限制单个客户端最大同时存在的代理数，默认无限制。 No userConnTimeout int 用户建立连接后等待客户端响应的超时时间，单位秒，默认为 10 秒。 No udpPacketSize int 代理 UDP 服务时支持的最大包长度，默认为 1500，服务端和客户端的值需要一致。 No natholeAnalysisDataReserveHours int 打洞策略数据的保留时间，默认为 168 小时，即 7 天。 No allowPorts []PortsRange 允许代理绑定的服务端端口。 No httpPlugins []HTTPPluginOptions 服务端 HTTP 插件配置。 No AuthServerConfig Field Type Description Required method string 鉴权方式，可选值为 token 或 oidc，默认为 token。 No additionalScopes []string 鉴权信息附加范围，可选值为 HeartBeats 和 NewWorkConns No token string 在 method 为 token 时生效，客户端需要设置一样的值才能鉴权通过。与 tokenSource 字段互斥。 No tokenSource ValueSource 从文件中加载 token 的配置。与 token 字段互斥。 No oidc AuthOIDCServerConfig oidc 鉴权配置。 No AuthOIDCServerConfig Field Type Description Required issuer string No audience string No skipExpiryCheck bool No skipIssuerCheck bool No ServerTransportConfig Field Type Description Required tcpMuxKeepaliveInterval int tcp mux 的心跳检查间隔时间，单位秒。 No tcpKeepalive int 和客户端底层 TCP 连接的 keepalive 间隔时间，单位秒，配置为负数表示不启用。 No maxPoolCount int 允许客户端设置的最大连接池大小，如果客户端配置的值大于此值，会被强制修改为最大值，默认为 5。 No heartbeatTimeout int 服务端和客户端心跳连接的超时时间，单位秒，默认为 90 秒。 No quic QUICOptions QUIC 协议配置参数。 No tls TLSServerConfig 服务端 TLS 协议配置。 No TLSServerConfig Field Type Description Required force bool 是否只接受启用了 TLS 的客户端连接。 No TLSConfig TLS 协议配置，内嵌结构。 No HTTPPluginOptions Field Type Description Required name string 插件名称。 Yes addr string 插件接口的地址。 Yes path string 插件接口的 Path。 Yes ops []string 插件需要生效的操作列表，具体可选值请参考服务端插件的说明文档。 Yes tlsVerify bool 当插件地址为 HTTPS 协议时，是否校验插件的 TLS 证书，默认为不校验。 No SSHTunnelGateway Field Type Description Required bindPort int SSH 服务器监听端口。 YES privateKeyFile string SSH 服务器私钥文件路径。若为空，frps将读取autoGenPrivateKeyPath路径下的私钥文件。 No autoGenPrivateKeyPath string 私钥文件自动生成路径，默认为./.autogen_ssh_key。若文件不存在或内容为空，frps将自动生成RSA私钥文件并存储到该路径。 No authorizedKeysFile string SSH 客户端授权密钥文件路径。若为空，则不进行SSH客户端鉴权认证。非空可实现SSH免密登录认证。 No ","categories":"","description":"frp 服务端详细配置说明。\n","excerpt":"frp 服务端详细配置说明。\n","ref":"/zh-cn/docs/reference/server-configures/","tags":"","title":"服务端配置"},{"body":"transport.useEncryption 和 STCP 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存在被中间人攻击的风险。为此 frp 支持 frpc 和 frps 之间的流量通过 TLS 协议加密，并且支持客户端或服务端单向验证，双向验证等功能。\n当 frps.toml 中 transport.tls.force = true 时，表示 server 端只接受 TLS 连接的客户端，这也是 frps 验证 frpc 身份的前提条件。如果 frps.toml 中 transport.tls.trustedCaFile 内容是有效的话，那么默认就会开启 transport.tls.force = true。\n注意：启用此功能后除 xtcp ，可以不用再设置 use_encryption 重复加密\nTLS 默认开启方式 从 v0.50.0 开始，transport.tls.enable 的默认值将会为 true，默认开启 TLS 协议加密。\n如果 frps 端没有配置证书，则会使用随机生成的证书来加密流量。\n默认情况下，frpc 开启 TLS 加密功能，但是不校验 frps 的证书。\nfrpc 单向校验 frps 身份 # frpc.toml transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" # frps.toml transport.tls.certFile = \"/to/cert/path/server.crt\" transport.tls.keyFile = \"/to/key/path/server.key\" frpc 需要额外加载 ca 证书，frps 需要额外指定 TLS 配置。frpc 通过 ca 证书单向验证 frps 的身份。这就要求 frps 的 server.crt 对 frpc 的 ca 是合法的。\n合法: 如果证书是 ca 签发的，或者证书是在 ca 的信任链中，那即认为: 该证书对 ca 而言是合法的。\nfrps 单向验证 frpc 的身份 # frpc.toml transport.tls.certFile = \"/to/cert/path/client.crt\" transport.tls.keyFile = \"/to/key/path/client.key\" # frps.toml transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" frpc 需要额外加载 TLS 配置，frps 需要额外加载 ca 证书。frps 通过 ca 证书单向验证 frpc 的身份。这就要求 frpc 的 client.crt 对 frps 的 ca 是合法的。\n双向验证 # frpc.toml transport.tls.certFile = \"/to/cert/path/client.crt\" transport.tls.keyFile = \"/to/key/path/client.key\" transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" # frps.toml transport.tls.certFile = \"/to/cert/path/server.crt\" transport.tls.keyFile = \"/to/key/path/server.key\" transport.tls.trustedCaFile = \"/to/ca/path/ca.crt\" 双向验证即 frpc 和 frps 通过本地 ca 证书去验证对方的身份。理论上 frpc 和 frps 的 ca 证书可以不同，只要能验证对方身份即可。\nOpenSSL 生成证书示例 x509: certificate relies on legacy Common Name field, use SANs or temporarily enable Common Name matching with GODEBUG=x509ignoreCN=0\n如果出现上述报错，是因为 go 1.15 版本开始废弃 CommonName，因此推荐使用 SAN 证书。\n下面简单示例如何用 openssl 生成 ca 和双方 SAN 证书。\n准备默认 OpenSSL 配置文件于当前目录。此配置文件在 linux 系统下通常位于 /etc/pki/tls/openssl.cnf，在 mac 系统下通常位于 /System/Library/OpenSSL/openssl.cnf。\n如果存在，则直接拷贝到当前目录，例如 cp /etc/pki/tls/openssl.cnf ./my-openssl.cnf。如果不存在可以使用下面的命令来创建。\ncat \u003e my-openssl.cnf \u003c\u003c EOF [ ca ] default_ca = CA_default [ CA_default ] x509_extensions = usr_cert [ req ] default_bits = 2048 default_md = sha256 default_keyfile = privkey.pem distinguished_name = req_distinguished_name attributes = req_attributes x509_extensions = v3_ca string_mask = utf8only [ req_distinguished_name ] [ req_attributes ] [ usr_cert ] basicConstraints = CA:FALSE nsComment = \"OpenSSL Generated Certificate\" subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer [ v3_ca ] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = CA:true EOF 生成默认 ca:\nopenssl genrsa -out ca.key 2048 openssl req -x509 -new -nodes -key ca.key -subj \"/CN=example.ca.com\" -days 5000 -out ca.crt 生成 frps 证书:\nopenssl genrsa -out server.key 2048 openssl req -new -sha256 -key server.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=server.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\")) \\ -out server.csr openssl x509 -req -days 365 -sha256 \\ -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:localhost,IP:127.0.0.1,DNS:example.server.com\") \\ -out server.crt 生成 frpc 的证书:\nopenssl genrsa -out client.key 2048 openssl req -new -sha256 -key client.key \\ -subj \"/C=XX/ST=DEFAULT/L=DEFAULT/O=DEFAULT/CN=client.com\" \\ -reqexts SAN \\ -config \u003c(cat my-openssl.cnf \u003c(printf \"\\n[SAN]\\nsubjectAltName=DNS:client.com,DNS:example.client.com\")) \\ -out client.csr openssl x509 -req -days 365 -sha256 \\ -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial \\ -extfile \u003c(printf \"subjectAltName=DNS:client.com,DNS:example.client.com\") \\ -out client.crt 在本例中，server.crt 和 client.crt 都是由默认 ca 签发的，因此他们对默认 ca 是合法的。\n","categories":"","description":"","excerpt":"transport.useEncryption 和 STCP 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存 …","ref":"/zh-cn/docs/features/common/network/network-tls/","tags":"","title":"自定义 TLS 协议加密"},{"body":"ClientConfig Field Type Description Required ClientCommonConfig Client common configuration. Yes proxies []ProxyConfig Proxy configuration. Different proxy types correspond to different configurations, such as TCPProxyConfig or HTTPProxyConfig. No visitors []VisitorConfig Visitor configuration. Different visitor types correspond to different configurations, such as STCPVisitorConfig. No ClientCommonConfig Field Type Description Required auth AuthClientConfig Client authentication configuration. No user string Username. After setting this parameter, proxy names will be modified to {user}.{proxyName} to avoid proxy name conflicts with other users. No serverAddr string Address to connect to the server. No serverPort int Port to connect to the server, default is 7000. No natHoleStunServer string STUN server address required for xtcp hole punching, default is stun.easyvoip.com:3478. No dnsServer string DNS server address to use. By default, it uses the system-configured DNS server. Specifying this parameter can force replacement with a custom DNS server address. No loginFailExit bool Whether to exit after first login failure, default is true. No start []string Specify to enable partial proxies. When many proxies are configured but only some of them are desired to be enabled, this parameter can be used to specify them. Default is to enable all. No log LogConfig Log configuration. No webServer WebServerConfig Client AdminServer configuration. No transport ClientTransportConfig Client network layer configuration. No virtualNet VirtualNetConfig Virtual network configuration, Alpha feature. No featureGates map[string]bool Feature gates, used to enable or disable experimental features. No udpPacketSize int Maximum packet length supported when proxying UDP services, default is 1500. Server and client need to maintain consistent configuration. No metadatas map[string]string Additional metadata that will be passed to server plugins to provide additional capabilities. No includes []string Specify additional configuration file directories where proxy and visitor configurations will be read and loaded. No ClientTransportConfig Field Type Description Required protocol string Communication protocol with frps. Options are tcp, kcp, quic, websocket, wss. Default is tcp. No dialServerTimeout int Timeout for connecting to the server, default is 10s. No dialServerKeepalive int Keepalive interval time for the underlying TCP connection with the server, in seconds. No connectServerLocalIP string Local IP bound when connecting to the server. No proxyURL string Proxy address used to connect to the server, format: {protocol}://user:passwd@192.168.1.128:8080. Protocol currently supports http, socks5, ntlm. No poolCount int Connection pool size. No tcpMux bool TCP multiplexing, enabled by default. No tcpMuxKeepaliveInterval int Heartbeat check interval time for tcp_mux. No quic QUICOptions QUIC protocol configuration parameters. No heartbeatInterval int Interval time for sending heartbeat packets to the server, default is 30s. It is recommended to enable tcp_mux_keepalive_interval and set this value to -1. No heartbeatTimeout int Timeout for heartbeat with the server, default is 90s. No tls TLSClientConfig Client TLS protocol configuration. No TLSClientConfig Field Type Description Required enable bool Whether to enable TLS connection with the server, enabled by default. No disableCustomTLSFirstByte bool When TLS connection is enabled, do not send the 0x17 special byte. Default is true. When configured as true, it cannot be reused with vhostHTTPSPort port. No TLSConfig TLS protocol configuration, embedded structure. No AuthClientConfig Field Type Description Required method string Authentication method. Options are token or oidc, default is token. No additionalScopes []string Additional scope for authentication information. Options are HeartBeats and NewWorkConns No token string Effective when method is token. Client needs to set the same value to pass authentication. Mutually exclusive with tokenSource field. No tokenSource ValueSource Configuration for loading token from file. Mutually exclusive with token field. No oidc AuthOIDCClientConfig OIDC authentication configuration. No AuthOIDCClientConfig Field Type Description Required clientID string OIDC client ID. No clientSecret string OIDC client secret. No audience string OIDC audience parameter. No scope string OIDC scope parameter. No tokenEndpointURL string OIDC token endpoint URL. No additionalEndpointParams map[string]string Additional endpoint parameters. No trustedCaFile string Trusted CA certificate file path for verifying OIDC server TLS certificate. No insecureSkipVerify bool Skip TLS certificate verification, not recommended for production use. No proxyURL string Proxy server URL to use when accessing OIDC token endpoint. No tokenSource ValueSource Configuration for dynamically obtaining OIDC token from external source. When configured, other OIDC configuration fields will be ignored. No VirtualNetConfig Field Type Description Required address string IP address and network segment of the virtual network interface, format is CIDR (e.g. “100.86.0.1/24”). Yes ","categories":"","description":"Detailed configuration description for frp client.\n","excerpt":"Detailed configuration description for frp client.\n","ref":"/en/docs/reference/client-configures/","tags":"","title":"Client Configuration"},{"body":"How it works frp consists of two main components: the client (frpc) and the server (frps). Typically, the server is deployed on a machine with a public IP address, while the client is deployed on the machine where the intranet service that needs to be penetrated is located.\nSince intranet services lack public IP addresses, they cannot be directly accessed by users outside the local network. Users access the server’s frps, and frp is responsible for routing requests to the corresponding intranet machine based on the requested port or other information, thus enabling communication.\nProxy In frp, a proxy corresponds to an intranet service that needs to be publicly accessible. A client can configure multiple proxies simultaneously to meet different requirements.\nProxy Types frp supports multiple proxy types to adapt to different usage scenarios. Here are some common proxy types:\nTCP: Provides pure TCP port mapping, allowing the server to route requests to different intranet services based on different ports. UDP: Provides pure UDP port mapping, similar to TCP proxy but for UDP traffic. HTTP: Designed specifically for HTTP applications, supporting additional features such as modifying Host Header and adding authentication. HTTPS: Similar to HTTP proxy but specifically designed for handling HTTPS traffic. STCP: Provides secure TCP intranet proxy, requiring frpc deployment on both the accessed and accessing machines, without needing to expose ports on the server. SUDP: Provides secure UDP intranet proxy, similar to STCP, requiring frpc deployment on both the accessed and accessing machines, without needing to expose ports on the server. XTCP: Point-to-point intranet penetration proxy, similar to STCP, but traffic does not need to be relayed through the server. TCPMUX: Supports multiplexing of server TCP ports, allowing access to different intranet services through the same port. Each proxy type is suitable for different usage scenarios, and you can choose the appropriate proxy type to configure frp according to your needs.\n","categories":"","description":"Understanding these concepts will help you better understand and use frp.\n","excerpt":"Understanding these concepts will help you better understand and use …","ref":"/en/docs/concepts/","tags":"","title":"Concepts"},{"body":"HTTP and HTTPS are protocols for which frp provides some special capabilities. Essentially, these two application layer protocols currently use TCP as the underlying protocol.\nIf you don’t need to use related special functions, you can directly use TCP type proxies, which is simpler and more convenient.\nA characteristic of HTTP and HTTPS protocols is that the sent requests all have a Host field, which describes the service to be accessed. Based on this characteristic, the frp server only needs to listen on one port (specified by vhostHTTPPort and vhostHTTPSPort). It can then decide which proxy to route to based on the request’s Host, without needing to bind a port for each service like TCP type proxies.\n","categories":"","description":"Learn about frp `HTTP`, `HTTPS` type proxies.\n","excerpt":"Learn about frp `HTTP`, `HTTPS` type proxies.\n","ref":"/en/docs/features/http-https/","tags":"","title":"HTTP \u0026 HTTPS"},{"body":"HTTP 和 HTTPS 是 frp 中针对这两种协议额外提供了一些特殊的能力。本质上目前这两种应用层协议的底层协议都是 TCP。\n如果不需要用到相关的特殊功能，可以直接使用 TCP 类型的代理，更加简单方便。\nHTTP 和 HTTPS 协议的一个特点是发送的请求都具有 Host 字段，通过该字段描述要访问的服务。基于这个特点，frp 服务端只需要监听在一个端口(通过 vhostHTTPPort 和 vhostHTTPSPort 指定)。就可以根据请求的 Host 来决定需要路由给哪一个代理，而不需要像 TCP 类型那样为每一个服务绑定一个端口。\n","categories":"","description":"了解 frp `HTTP`, `HTTPS` 类型的代理。\n","excerpt":"了解 frp `HTTP`, `HTTPS` 类型的代理。\n","ref":"/zh-cn/docs/features/http-https/","tags":"","title":"HTTP \u0026 HTTPS"},{"body":"Since all clients share one frps HTTP service port, anyone who knows your domain name and URL can access your services deployed in the intranet. However, in some scenarios, you need to ensure that only limited users can access.\nfrp supports protecting your web services through HTTP Basic Auth, requiring users to access your services through username and password.\nThis feature is currently limited to HTTP type proxies and requires adding username and password settings in frpc’s proxy configuration.\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] httpUser = \"abc\" httpPassword = \"abc\" When accessing http://test.yourdomain.com through a browser, you need to enter the configured username and password to access.\n","categories":"","description":"","excerpt":"Since all clients share one frps HTTP service port, anyone who knows …","ref":"/en/docs/features/http-https/auth/","tags":"","title":"Set BasicAuth Authentication"},{"body":"ClientConfig Field Type Description Required ClientCommonConfig 客户端通用配置。 Yes proxies []ProxyConfig 代理配置，不同的代理类型对应不同的配置，例如 TCPProxyConfig 或 HTTPProxyConfig。 No visitors []VisitorConfig 访问者配置，不同的访问者类型对应不同的配置，例如 STCPVisitorConfig。 No ClientCommonConfig Field Type Description Required auth AuthClientConfig 客户端鉴权配置。 No user string 用户名，设置此参数后，代理名称会被修改为 {user}.{proxyName}，避免代理名称和其他用户冲突。 No serverAddr string 连接服务端的地址。 No serverPort int 连接服务端的端口，默认为 7000。 No natHoleStunServer string xtcp 打洞所需的 stun 服务器地址，默认为 stun.easyvoip.com:3478。 No dnsServer string 使用 DNS 服务器地址，默认使用系统配置的 DNS 服务器，指定此参数可以强制替换为自定义的 DNS 服务器地址。 No loginFailExit bool 第一次登陆失败后是否退出，默认为 true。 No start []string 指定启用部分代理，当配置了较多代理，但是只希望启用其中部分时可以通过此参数指定，默认为全部启用。 No log LogConfig 日志配置。 No webServer WebServerConfig 客户端 AdminServer 配置。 No transport ClientTransportConfig 客户端网络层配置。 No virtualNet VirtualNetConfig 虚拟网络配置，Alpha 特性。 No featureGates map[string]bool 特性门控，用于启用或禁用实验性功能。 No udpPacketSize int 代理 UDP 服务时支持的最大包长度，默认为 1500，服务端和客户端需要保持配置一致。 No metadatas map[string]string 附加元数据，会传递给服务端插件，提供附加能力。 No includes []string 指定额外的配置文件目录，其中的 proxy 和 visitor 配置会被读取加载。 No ClientTransportConfig Field Type Description Required protocol string 和 frps 之间的通信协议，可选值为 tcp, kcp, quic, websocket, wss。默认为 tcp。 No dialServerTimeout int 连接服务端的超时时间，默认为 10s。 No dialServerKeepalive int 和服务端底层 TCP 连接的 keepalive 间隔时间，单位秒。 No connectServerLocalIP string 连接服务端时所绑定的本地 IP。 No proxyURL string 连接服务端使用的代理地址，格式为 {protocol}://user:passwd@192.168.1.128:8080 protocol 目前支持 http、socks5、ntlm。 No poolCount int 连接池大小。 No tcpMux bool TCP 多路复用，默认启用。 No tcpMuxKeepaliveInterval int tcp_mux 的心跳检查间隔时间。 No quic QUICOptions QUIC 协议配置参数。 No heartbeatInterval int 向服务端发送心跳包的间隔时间，默认为 30s。建议启用 tcp_mux_keepalive_interval，将此值设置为 -1。 No heartbeatTimeout int 和服务端心跳的超时时间，默认为 90s。 No tls TLSClientConfig 客户端 TLS 协议配置。 No TLSClientConfig Field Type Description Required enable bool 是否和服务端之间启用 TLS 连接，默认启用。 No disableCustomTLSFirstByte bool 启用 TLS 连接时，不发送 0x17 特殊字节。默认为 true。当配置为 true 时，无法和 vhostHTTPSPort 端口复用。 No TLSConfig TLS 协议配置，内嵌结构。 No AuthClientConfig Field Type Description Required method string 鉴权方式，可选值为 token 或 oidc，默认为 token。 No additionalScopes []string 鉴权信息附加范围，可选值为 HeartBeats 和 NewWorkConns No token string 在 method 为 token 时生效，客户端需要设置一样的值才能鉴权通过。与 tokenSource 字段互斥。 No tokenSource ValueSource 从文件中加载 token 的配置。与 token 字段互斥。 No oidc AuthOIDCClientConfig oidc 鉴权配置。 No AuthOIDCClientConfig Field Type Description Required clientID string OIDC 客户端 ID。 No clientSecret string OIDC 客户端密钥。 No audience string OIDC audience 参数。 No scope string OIDC scope 参数。 No tokenEndpointURL string OIDC 令牌端点 URL。 No additionalEndpointParams map[string]string 附加的端点参数。 No trustedCaFile string 信任的 CA 证书文件路径，用于验证 OIDC 服务器的 TLS 证书。 No insecureSkipVerify bool 跳过 TLS 证书验证，不推荐在生产环境使用。 No proxyURL string 访问 OIDC 令牌端点时使用的代理服务器 URL。 No tokenSource ValueSource 从外部来源动态获取 OIDC token 的配置。配置此字段后，其他 OIDC 配置字段将被忽略。 No VirtualNetConfig Field Type Description Required address string 虚拟网络接口的 IP 地址和网段，格式为 CIDR (例如 “100.86.0.1/24”)。 Yes ","categories":"","description":"frp 客户端的详细配置说明。\n","excerpt":"frp 客户端的详细配置说明。\n","ref":"/zh-cn/docs/reference/client-configures/","tags":"","title":"客户端配置"},{"body":"工作原理 frp 主要由两个组件组成：客户端(frpc) 和 服务端(frps)。通常情况下，服务端部署在具有公网 IP 地址的机器上，而客户端部署在需要穿透的内网服务所在的机器上。\n由于内网服务缺乏公网 IP 地址，因此无法直接被非局域网内的用户访问。用户通过访问服务端的 frps，frp 负责根据请求的端口或其他信息将请求路由到相应的内网机器，从而实现通信。\n代理 在 frp 中，一个代理对应一个需要公开访问的内网服务。一个客户端可以同时配置多个代理，以满足不同的需求。\n代理类型 frp 支持多种代理类型，以适应不同的使用场景。以下是一些常见的代理类型：\nTCP：提供纯粹的 TCP 端口映射，使服务端能够根据不同的端口将请求路由到不同的内网服务。 UDP：提供纯粹的 UDP 端口映射，与 TCP 代理类似，但用于 UDP 流量。 HTTP：专为 HTTP 应用设计，支持修改 Host Header 和增加鉴权等额外功能。 HTTPS：类似于 HTTP 代理，但专门用于处理 HTTPS 流量。 STCP：提供安全的 TCP 内网代理，要求在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。 SUDP：提供安全的 UDP 内网代理，与 STCP 类似，需要在被访问者和访问者的机器上都部署 frpc，不需要在服务端暴露端口。 XTCP：点对点内网穿透代理，与 STCP 类似，但流量不需要经过服务器中转。 TCPMUX：支持服务端 TCP 端口的多路复用，允许通过同一端口访问不同的内网服务。 每种代理类型适用于不同的使用情境，您可以根据需求选择合适的代理类型来配置 frp。\n","categories":"","description":"了解以下概念有助于更好地理解和使用 frp。\n","excerpt":"了解以下概念有助于更好地理解和使用 frp。\n","ref":"/zh-cn/docs/concepts/","tags":"","title":"概念"},{"body":"由于所有客户端共用一个 frps 的 HTTP 服务端口，任何知道你的域名和 URL 的人都能访问到你部署在内网的服务，但是在某些场景下需要确保只有限定的用户才能访问。\nfrp 支持通过 HTTP Basic Auth 来保护你的 web 服务，使用户需要通过用户名和密码才能访问到你的服务。\n该功能目前仅限于 HTTP 类型的代理，需要在 frpc 的代理配置中添加用户名和密码的设置。\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"test.yourdomain.com\"] httpUser = \"abc\" httpPassword = \"abc\" 通过浏览器访问 http://test.yourdomain.com，需要输入配置的用户名和密码才能访问。\n","categories":"","description":"","excerpt":"由于所有客户端共用一个 frps 的 HTTP 服务端口，任何知道你的域名和 URL 的人都能访问到你部署在内网的服务，但是在某些场景下需要 …","ref":"/zh-cn/docs/features/http-https/auth/","tags":"","title":"设置 BasicAuth 鉴权"},{"body":"When multiple people are using one frps simultaneously, using custom subdomains is more convenient.\nBy configuring subdomainHost in frps’s configuration file, you can enable this feature. After that, in frpc’s http and https type proxies, you can configure a subdomain parameter instead of configuring customDomains.\nYou only need to resolve *.{subdomainHost} to the server where frps is located. After that, users can specify their own subdomain for their web services through subdomain, and access their web services through {subdomain}.{subdomainHost}.\n# frps.toml subdomainHost = \"frps.com\" Resolve the wildcard domain *.frps.com to the IP address of the server where frps is located.\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 subdomain = \"test\" After both frps and frpc start successfully, you can access the intranet web service through test.frps.com.\nNote: If frps is configured with subdomainHost, then customDomains cannot be subdomains or wildcard domains belonging to subdomainHost.\nIn the same HTTP or HTTPS type proxy, customDomains and subdomain can be configured simultaneously.\n","categories":"","description":"","excerpt":"When multiple people are using one frps simultaneously, using custom …","ref":"/en/docs/features/http-https/subdomain/","tags":"","title":"Custom Subdomain"},{"body":"","categories":"","description":"Here you will find multiple common use cases and configuration examples that you can use to deploy and experience these examples yourself.\n","excerpt":"Here you will find multiple common use cases and configuration …","ref":"/en/docs/examples/","tags":"","title":"Examples"},{"body":"ProxyBaseConfig Field Type Description Required name string Proxy name. Yes type string Proxy type. Options are tcp, udp, http, https, tcpmux, stcp, sudp, xtcp. Yes enabled *bool Whether this proxy is enabled, default is true. Set to false to disable this proxy, allowing individual control over each proxy’s enabled state. No annotations map[string]string Proxy annotation information that will be displayed in the server’s dashboard. No transport ProxyTransport Proxy network layer configuration. No metadatas map[string]string Additional metadata that will be passed to server plugins to provide additional capabilities. No loadBalancer LoadBalancerConfig Load balancing configuration. No healthCheck HealthCheckConfig Health check configuration. No ProxyBackend Proxy backend service configuration. Yes ProxyTransport Field Type Description Required useEncryption bool Whether to enable encryption functionality. When enabled, communication content between this proxy and the server will be encrypted. If frpc has enabled global TLS, this parameter is not needed. No useCompression bool Whether to enable compression functionality. When enabled, communication content between this proxy and the server will be compressed. No bandwidthLimit string Set bandwidth rate limiting for a single proxy, in MB or KB units. 0 means no limit. If enabled, it will apply to the corresponding frpc by default. No bandwidthLimitMode string Rate limiting type, client-side or server-side rate limiting. Options are client and server, default is client-side rate limiting. No proxyProtocolVersion string Version of proxy protocol to enable. Options are v1 and v2. If enabled, frpc will send proxy protocol after establishing connection with local service, containing original request IP address and port information. No ProxyBackend Field Type Description Required localIP string IP of the local service being proxied, default is 127.0.0.1. No localPort int Port of the local service being proxied. No plugin ClientPluginOptions Client plugin configuration. If client plugin is enabled, localIP and localPort don’t need to be configured, and traffic will be handled by the client plugin. Different plugin types correspond to different configurations, such as HTTPProxyPluginOptions. No LoadBalancerConfig Field Type Description Required group string Load balancing group name. User requests will be sent to proxies in the same group using round-robin. Yes groupKey string Load balancing group key for authenticating the load balancing group. Only proxies with the same groupKey will be added to the same group. No HealthCheckConfig Field Type Description Required type string Health check type. Options are tcp and http. After configuration, health check is enabled. tcp considers service healthy if connection succeeds, http requires interface to return 2xx status codes to consider service healthy. Yes timeoutSeconds int Health check timeout (seconds), default is 3s. No maxFailed int Consecutive health check error count. How many consecutive check errors to consider service unhealthy, default is 1. No intervalSeconds int Health check interval (seconds). How often to perform health checks, default is 10s. No path string Health check HTTP interface. If health check type is http, this parameter needs to be configured to specify the path for sending http requests, such as /health. No httpHeaders []HTTPHeader Health check HTTP request headers, only effective when health check type is http. No DomainConfig Field Type Description Required customDomains []string Custom domain list. No subdomain string Subdomain. No TCPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes remotePort int Port bound by the server. Traffic accessing this port on the server will be forwarded to the corresponding local service. No UDPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes remotePort int Port bound by the server. Traffic accessing this port on the server will be forwarded to the corresponding local service. No HTTPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes DomainConfig Domain configuration. Yes locations []string URL routing configuration. No httpUser string HTTP Basic Auth username. No httpPassword string HTTP Basic Auth password. No hostHeaderRewrite string Replace Host Header. No requestHeaders HeaderOperations Request Header operation configuration. No responseHeaders HeaderOperations Response Header operation configuration. No routeByHTTPUser string Route by HTTP Basic Auth user. No HTTPSProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes DomainConfig Domain configuration. Yes TCPMuxProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes DomainConfig Domain configuration. Yes httpUser string Username. If this parameter is configured, correct identity information needs to be attached via Proxy-Authorization when establishing connection through HTTP CONNECT. No httpPassword string Password. No routeByHTTPUser string Route by HTTP Basic Auth user. No multiplexer string Multiplexer type, currently only supports httpconnect. No STCPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes secretKey string Secret key. The secret key between server and access side must be consistent for the access side to access the server. No allowUsers []string List of visitor users allowed to access. By default, only visitors under the same user are allowed to access. Configure as * to allow any visitor to access. No XTCPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes secretKey string Secret key. The secret key between server and access side must be consistent for the access side to access the server. No allowUsers []string List of visitor users allowed to access. By default, only visitors under the same user are allowed to access. Configure as * to allow any visitor to access. No natTraversal NatTraversalConfig NAT traversal configuration. No SUDPProxyConfig Field Type Description Required ProxyBaseConfig Base configuration. Yes secretKey string Secret key. The secret key between server and access side must be consistent for the access side to access the server. No allowUsers []string List of visitor users allowed to access. By default, only visitors under the same user are allowed to access. Configure as * to allow any visitor to access. No ","categories":"","description":"Detailed configuration description for frp proxies.\n","excerpt":"Detailed configuration description for frp proxies.\n","ref":"/en/docs/reference/proxy/","tags":"","title":"Proxy Configuration"},{"body":"The (S) in STCP and SUDP stands for Secret. Its purpose is to provide secure access capability for TCP and UDP type services, avoiding direct exposure of ports on the public network that anyone can access.\nThese two proxy types require deploying frp clients on both the machine where the accessed service is located and the machine of the user who wants to access it. The machine where the accessed service is located is called the server side, and the other end is called the access side.\nfrp will listen on a port on the access side and map it to the server side port. Users on the access side need to provide the same secret key to connect successfully, thus ensuring security.\n","categories":"","description":"Learn about frp `STCP`, `SUDP` type proxies.\n","excerpt":"Learn about frp `STCP`, `SUDP` type proxies.\n","ref":"/en/docs/features/stcp-sudp/","tags":"","title":"STCP \u0026 SUDP"},{"body":"STCP 和 SUDP 的 (S) 的含义是 Secret。其作用是为 TCP 和 UDP 类型的服务提供一种安全访问的能力，避免让端口直接暴露在公网上导致任何人都能访问到。\n这两种代理要求在被访问服务的机器上以及要访问的用户的机器上都部署上 frp 的客户端。被访问的服务所在机器叫做服务端，另一端叫做访问端。\nfrp 会在访问端监听一个端口和服务端的端口做映射。访问端的用户需要提供相同的密钥才能连接成功，从而保证安全性。\n","categories":"","description":"了解 frp `STCP`, `SUDP` 类型的代理。\n","excerpt":"了解 frp `STCP`, `SUDP` 类型的代理。\n","ref":"/zh-cn/docs/features/stcp-sudp/","tags":"","title":"STCP \u0026 SUDP"},{"body":"ProxyBaseConfig Field Type Description Required name string 代理名称。 Yes type string 代理类型，可选值为 tcp, udp, http, https, tcpmux, stcp, sudp, xtcp。 Yes enabled *bool 是否启用该代理，默认为 true。设置为 false 可禁用该代理，用于单独控制每个代理的启用状态。 No annotations map[string]string 代理的注释信息，会被展示在 server 的 dashboard 中。 No transport ProxyTransport 代理网络层配置。 No metadatas map[string]string 附加元数据，会传递给服务端插件，提供附加能力。 No loadBalancer LoadBalancerConfig 负载均衡配置。 No healthCheck HealthCheckConfig 健康检查配置。 No ProxyBackend 代理后端服务配置。 Yes ProxyTransport Field Type Description Required useEncryption bool 是否启用加密功能，启用后该代理和服务端之间的通信内容都会被加密传输，如果 frpc 启用了全局 TLS，则不需要再启用此参数。 No useCompression bool 是否启用压缩功能，启用后该代理和服务端之间的通信内容都会被压缩传输。 No bandwidthLimit string 设置单个 proxy 的带宽限流，单位为 MB 或 KB，0 表示不限制，如果启用，默认会作用于对应的 frpc。 No bandwidthLimitMode string 限流类型，客户端限流或服务端限流，可选值为 client 和 server，默认为客户端限流。 No proxyProtocolVersion string 启用 proxy protocol 协议的版本，可选值为 v1 和 v2。如果启用，则 frpc 和本地服务建立连接后会发送 proxy protocol 的协议，包含了原请求的 IP 地址和端口等内容。 No ProxyBackend Field Type Description Required localIP string 被代理的本地服务 IP，默认为 127.0.0.1。 No localPort int 被代理的本地服务端口。 No plugin ClientPluginOptions 客户端插件配置，如果启用了客户端插件，则不需要配置 localIP 和 localPort，流量会由客户端插件接管。不同的插件类型对应不同的配置，例如 HTTPProxyPluginOptions。 No LoadBalancerConfig Field Type Description Required group string 负载均衡分组名称，用户请求会以轮询的方式发送给同一个 group 中的代理。 Yes groupKey string 负载均衡分组密钥，用于对负载均衡分组进行鉴权，groupKey 相同的代理才会被加入到同一个分组中。 No HealthCheckConfig Field Type Description Required type string 健康检查类型，可选值为 tcp 和 http，配置后启用健康检查功能，tcp 是连接成功则认为服务健康，http 要求接口返回 2xx 的状态码则认为服务健康。 Yes timeoutSeconds int 健康检查超时时间(秒)，默认为 3s。 No maxFailed int 健康检查连续错误次数，连续检查错误多少次认为服务不健康，默认为 1。 No intervalSeconds int 健康检查周期(秒)，每隔多长时间进行一次健康检查，默认为 10s。 No path string 健康检查的 HTTP 接口，如果健康检查类型是 http，则需要配置此参数，指定发送 http 请求的 path，例如 /health。 No httpHeaders []HTTPHeader 健康检查的 HTTP 请求头，仅在健康检查类型是 http 时生效。 No DomainConfig Field Type Description Required customDomains []string 自定义域名列表。 No subdomain string 子域名。 No TCPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes remotePort int 服务端绑定的端口，用户访问服务端此端口的流量会被转发到对应的本地服务。 No UDPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes remotePort int 服务端绑定的端口，用户访问服务端此端口的流量会被转发到对应的本地服务。 No HTTPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes DomainConfig 域名配置。 Yes locations []string URL 路由配置。 No httpUser string HTTP Basic Auth 用户名。 No httpPassword string HTTP Basic Auth 密码。 No hostHeaderRewrite string 替换 Host Header。 No requestHeaders HeaderOperations 对请求 Header 的操作配置。 No responseHeaders HeaderOperations 对响应 Header 的操作配置。 No routeByHTTPUser string 根据 HTTP Basic Auth user 路由。 No HTTPSProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes DomainConfig 域名配置。 Yes TCPMuxProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes DomainConfig 域名配置。 Yes httpUser string 用户名，如果配置此参数，通过 HTTP CONNECT 建立连接时需要通过 Proxy-Authorization 附加上正确的身份信息。 No httpPassword string 密码。 No routeByHTTPUser string 根据 HTTP Basic Auth user 路由。 No multiplexer string 复用器类型，目前仅支持 httpconnect。 No STCPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes secretKey string 密钥，服务端和访问端的密钥需要一致，访问端才能访问到服务端。 No allowUsers []string 允许访问的 visitor 用户列表，默认只允许同一用户下的 visitor 访问，配置为 * 则允许任何 visitor 访问。 No XTCPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes secretKey string 密钥，服务端和访问端的密钥需要一致，访问端才能访问到服务端。 No allowUsers []string 允许访问的 visitor 用户列表，默认只允许同一用户下的 visitor 访问，配置为 * 则允许任何 visitor 访问。 No natTraversal NatTraversalConfig NAT 穿透配置。 No SUDPProxyConfig Field Type Description Required ProxyBaseConfig 基础配置。 Yes secretKey string 密钥，服务端和访问端的密钥需要一致，访问端才能访问到服务端。 No allowUsers []string 允许访问的 visitor 用户列表，默认只允许同一用户下的 visitor 访问，配置为 * 则允许任何 visitor 访问。 No ","categories":"","description":"frp 代理的详细配置说明。\n","excerpt":"frp 代理的详细配置说明。\n","ref":"/zh-cn/docs/reference/proxy/","tags":"","title":"代理配置"},{"body":"","categories":"","description":"在这里，您将找到多个常见的使用场景和配置示例，可供您用来亲自部署和体验这些示例。\n","excerpt":"在这里，您将找到多个常见的使用场景和配置示例，可供您用来亲自部署和体验这些示例。\n","ref":"/zh-cn/docs/examples/","tags":"","title":"示例"},{"body":"在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。\n通过在 frps 的配置文件中配置 subdomainHost，就可以启用该特性。之后在 frpc 的 http、https 类型的代理中可以不配置 customDomains，而是配置一个 subdomain 参数。\n只需要将 *.{subdomainHost} 解析到 frps 所在服务器。之后用户可以通过 subdomain 自行指定自己的 web 服务所需要使用的二级域名，通过 {subdomain}.{subdomainHost} 来访问自己的 web 服务。\n# frps.toml subdomainHost = \"frps.com\" 将泛域名 *.frps.com 解析到 frps 所在服务器的 IP 地址。\n# frpc.toml [[proxies]] name = \"web\" type = \"http\" localPort = 80 subdomain = \"test\" frps 和 frpc 都启动成功后，通过 test.frps.com 就可以访问到内网的 web 服务。\n注：如果 frps 配置了 subdomainHost，则 customDomains 中不能是属于 subdomainHost 的子域名或者泛域名。\n同一个 HTTP 或 HTTPS 类型的代理中 customDomains 和 subdomain 可以同时配置。\n","categories":"","description":"","excerpt":"在多人同时使用一个 frps 时，通过自定义二级域名的方式来使用会更加方便。\n通过在 frps …","ref":"/zh-cn/docs/features/http-https/subdomain/","tags":"","title":"自定义二级域名"},{"body":"Steps Deploy frps on a machine with public IP\nDeploy frps and edit the frps.toml file. Here is a simplified configuration where we set the port for the frp server to receive client connections:\nbindPort = 7000 Deploy frpc on the intranet machine that needs to be accessed\nDeploy frpc and edit the frpc.toml file. Assume the public IP address of the server where frps is located is x.x.x.x. Here is an example configuration:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 localIP and localPort are configured as the address and port of the intranet service that needs to be accessed from the public network. remotePort represents the port listened on by the frp server, and traffic accessing this port will be forwarded to the corresponding port of the local service. Start frps and frpc\nAccess the intranet machine via SSH\nUse the following command to access the intranet machine via SSH, assuming the username is test:\nssh -o Port=6000 test@x.x.x.x frp will forward traffic sent to x.x.x.x:6000 to port 22 of the intranet machine.\n","categories":"","description":"Through simple configuration of TCP type proxy, users can access intranet servers.\n","excerpt":"Through simple configuration of TCP type proxy, users can access …","ref":"/en/docs/examples/ssh/","tags":"","title":"Access Intranet Machines via SSH"},{"body":"","categories":"","description":"Learn about the various features supported by frp.\n","excerpt":"Learn about the various features supported by frp.\n","ref":"/en/docs/features/","tags":"","title":"Features"},{"body":"URL Routing frp supports routing and forwarding to different backend services based on the URL path of the request.\nSpecify one or more URL prefixes that a proxy can match through the locations field in the configuration file (currently only supports maximum prefix matching, regex matching will be considered later). For example, specifying locations = \"/news\" means all requests with URLs starting with /news will be forwarded to this service.\n# frpc.toml [[proxies]] name = \"web01\" type = \"http\" localPort = 80 customDomains = [\"web.yourdomain.com\"] locations = [\"/\"] [[proxies]] name = \"web02\" type = \"http\" localPort = 81 customDomains = [\"web.yourdomain.com\"] locations = [\"/news\", \"/about\"] According to the above example configuration, all URL requests under the domain web.yourdomain.com with /news and /about as prefixes will be forwarded to web02, and the rest of the requests will be forwarded to web01.\n","categories":"","description":"","excerpt":"URL Routing frp supports routing and forwarding to different backend …","ref":"/en/docs/features/http-https/route/","tags":"","title":"Routing"},{"body":"VisitorBaseConfig Field Type Description Required name string Visitor name. Yes type string Visitor type. Options are stcp, sudp, xtcp. Yes enabled *bool Whether this visitor is enabled, default is true. Set to false to disable this visitor, allowing individual control over each visitor’s enabled state. No transport VisitorTransport Visitor network layer configuration. No secretKey string Secret key. The secret key between server and access side must be consistent for the access side to access the server. No serverUser string Username that the proxy to be accessed belongs to. If empty, defaults to current user. No serverName string Name of the proxy to be accessed. Yes bindAddr string Local address that visitor listens on. By accessing the listened address and port, connect to the remote proxy service. No bindPort int Local port that visitor listens on. If set to -1, means no need to listen on physical port, usually can be used as fallback for other visitors. Yes plugin VisitorPluginOptions Visitor plugin configuration for extending visitor functionality. Different plugin types correspond to different configurations. No VisitorTransport Field Type Description Required useEncryption bool Whether to enable encryption functionality. When enabled, communication content between this proxy and the server will be encrypted. If frpc has enabled global TLS, this parameter is not needed. No useCompression bool Whether to enable compression functionality. When enabled, communication content between this proxy and the server will be compressed. No STCPVisitorConfig Field Type Description Required VisitorBaseConfig Base configuration. Yes SUDPVisitorConfig Field Type Description Required VisitorBaseConfig Base configuration. Yes XTCPVisitorConfig Field Type Description Required VisitorBaseConfig Base configuration. Yes protocol string Tunnel underlying communication protocol. Options are quic and kcp, default is quic. No keepTunnelOpen bool Whether to keep tunnel open. If enabled, will periodically check tunnel status and try to keep it open. No maxRetriesAnHour int Number of attempts to open tunnel per hour, default value is 8. No minRetryInterval int Minimum interval time for retrying to open tunnel, in seconds, default is 90s. No fallbackTo string Name of other visitor to fallback to. No fallbackTimeoutMs int Fallback to other visitor after connection establishment exceeds this time (ms). No natTraversal NatTraversalConfig NAT traversal configuration. No ","categories":"","description":"Detailed configuration description for frp visitors.\n","excerpt":"Detailed configuration description for frp visitors.\n","ref":"/en/docs/reference/visitor/","tags":"","title":"Visitor Configuration"},{"body":"XTCP configuration is very similar to STCP. However, it uses P2P hole punching for penetration. If successful, subsequent traffic will not go through frps but will communicate directly, no longer limited by the bandwidth of the server where frps is located.\nSince hole punching success depends on the NAT type of the network, XTCP’s availability and stability cannot be guaranteed. In cases where reliable connections are needed, it is recommended to use STCP instead.\nWhen visitor is configured with keepTunnelOpen = true, frpc will periodically check whether the tunnel is open. If not, it will try to punch holes to establish the tunnel. This keeps the tunnel always open, avoiding delays when connecting to the peer service.\nBy default, visitor will try to punch holes after receiving user connections. If hole punching fails, you can try to establish connections multiple times. The program will try other hole punching strategies and may succeed after multiple retries. Once hole punching succeeds, subsequent new connections don’t need to punch holes again but can reuse the tunnel.\nFallback Mechanism You can configure fallback to stcp visitor to fall back to stcp connection establishment when hole punching fails.\nExample configuration:\n[[visitors]] name = \"stcp-visitor\" type = \"stcp\" serverName = \"stcp-test\" secretKey = \"abc\" bindPort = -1 [[visitors]] name = \"xtcp-visitor\" type = \"xtcp\" serverName = \"xtcp-test\" secretKey = \"abc\" bindAddr = \"127.0.0.1\" bindPort = 9002 fallbackTo = \"stcp-visitor\" fallbackTimeoutMs = 200 When connecting to 127.0.0.1:9002, if p2p hole punching hasn’t succeeded after 200ms, it will fall back to using stcp-visitor to establish connection. After fallback, the previously triggered hole punching operation will continue, and generally hole punching takes a long time to complete.\nIf hole punching succeeds, the next time a new connection is established, hole punching won’t be needed again, connection establishment will be completed quickly, and fallback won’t be triggered.\nNote that you should set the timeout reasonably based on the latency between the access side and the accessed side, to avoid timeout being too short where even if hole punching succeeds, the connection doesn’t have time to establish, causing fallback to be triggered constantly.\nSetting stcp-visitor’s bindPort to -1 means it doesn’t need to listen on a physical port, only accepting fallback connections.\n","categories":"","description":"Learn about frp `XTCP` type proxies.\n","excerpt":"Learn about frp `XTCP` type proxies.\n","ref":"/en/docs/features/xtcp/","tags":"","title":"XTCP"},{"body":"XTCP 的配置方式和 STCP 很类似。但是会采用 P2P 的方式进行打洞穿透，如果成功，后续的流量将不会经过 frps，而是直接通信，不再受到 frps 所在服务器的带宽限制。\n由于打洞成功率取决于所处网络的 NAT 类型，所以 XTCP 的可用性和稳定性无法保证。在需要可靠连接的情况下，建议使用 STCP 替代。\n当 visitor 配置了 keepTunnelOpen = true 时，frpc 会定期检测隧道是否打开，如果没有，则会尝试打洞建立隧道，这样可以始终保持隧道打开，在需要连接对端服务时，可以避免延迟。\n默认情况下，visitor 会在接收到用户连接后尝试打洞，如果打洞失败，可以尝试多次建立连接，程序会尝试其他的打洞策略，有可能在多次重试后成功打洞。一旦打洞成功，后续新增连接不必重复打洞，而是可以复用隧道。\nFallback 机制 可以通过配置 fallback 到 stcp visitor 实现在打洞失败时，回退到 stcp 建立连接。\n示例配置:\n[[visitors]] name = \"stcp-visitor\" type = \"stcp\" serverName = \"stcp-test\" secretKey = \"abc\" bindPort = -1 [[visitors]] name = \"xtcp-visitor\" type = \"xtcp\" serverName = \"xtcp-test\" secretKey = \"abc\" bindAddr = \"127.0.0.1\" bindPort = 9002 fallbackTo = \"stcp-visitor\" fallbackTimeoutMs = 200 当连接 127.0.0.1:9002 超过 200ms p2p 打洞还未成功的话，会回退到使用 stcp-visitor 建立连接。fallback 后，之前触发的打洞操作仍然会继续，一般来说打洞完成需要的耗时会比较长。\n如果打洞成功，下次建立新的连接时，将不需要再次打洞，会很快完成连接建立，不会触发 fallback。\n需要注意根据访问端和被访问端的延迟情况来合理设置超时时间，以避免超时时间太短，即使打洞成功连接也来不及建立，而一直触发 fallback。\nstcp-visitor 的 bindPort 设置为 -1 表示不需要监听物理端口，只接受 fallback 的连接即可。\n","categories":"","description":"了解 frp `XTCP` 类型的代理。\n","excerpt":"了解 frp `XTCP` 类型的代理。\n","ref":"/zh-cn/docs/features/xtcp/","tags":"","title":"XTCP"},{"body":"","categories":"","description":"了解 frp 支持的各种功能特性。\n","excerpt":"了解 frp 支持的各种功能特性。\n","ref":"/zh-cn/docs/features/","tags":"","title":"功能特性"},{"body":"VisitorBaseConfig Field Type Description Required name string 访问者名称。 Yes type string 访问者类型，可选值为 stcp, sudp, xtcp。 Yes enabled *bool 是否启用该访问者，默认为 true。设置为 false 可禁用该访问者，用于单独控制每个访问者的启用状态。 No transport VisitorTransport 访问者网络层配置。 No secretKey string 密钥，服务端和访问端的密钥需要一致，访问端才能访问到服务端。 No serverUser string 要访问的 proxy 所属的用户名，如果为空，则默认为当前用户。 No serverName string 要访问的 proxy 名称。 Yes bindAddr string visitor 监听的本地地址，通过访问监听的地址和端口，连接到远端代理的服务。 No bindPort int visitor 监听的本地端口，如果为 -1，表示不需要监听物理端口，通常可以用于作为其他 visitor 的 fallback。 Yes plugin VisitorPluginOptions 访问者插件配置，用于扩展 visitor 功能。不同的插件类型对应不同的配置。 No VisitorTransport Field Type Description Required useEncryption bool 是否启用加密功能，启用后该代理和服务端之间的通信内容都会被加密传输，如果 frpc 启用了全局 TLS，则不需要再启用此参数。 No useCompression bool 是否启用压缩功能，启用后该代理和服务端之间的通信内容都会被压缩传输。 No STCPVisitorConfig Field Type Description Required VisitorBaseConfig 基础配置。 Yes SUDPVisitorConfig Field Type Description Required VisitorBaseConfig 基础配置。 Yes XTCPVisitorConfig Field Type Description Required VisitorBaseConfig 基础配置。 Yes protocol string 隧道底层通信协议，可选 quic 和 kcp，默认为 quic。 No keepTunnelOpen bool 是否保持隧道打开，如果开启，会定期检查隧道状态并尝试保持打开。 No maxRetriesAnHour int 每小时尝试打开隧道的次数，默认值为 8。 No minRetryInterval int 重试打开隧道的最小间隔时间，单位: 秒，默认为 90s。 No fallbackTo string 回退到的其他 visitor 名称。 No fallbackTimeoutMs int 连接建立超过多长时间(ms) 后回退到其他 visitor。 No natTraversal NatTraversalConfig NAT 穿透配置。 No ","categories":"","description":"frp 访问者的详细配置说明。\n","excerpt":"frp 访问者的详细配置说明。\n","ref":"/zh-cn/docs/reference/visitor/","tags":"","title":"访问者配置"},{"body":"URL 路由 frp 支持根据请求的 URL 路径路由转发到不同的后端服务。\n通过配置文件中的 locations 字段指定一个或多个 proxy 能够匹配的 URL 前缀(目前仅支持最大前缀匹配，之后会考虑正则匹配)。例如指定 locations = \"/news\"，则所有 URL 以 /news 开头的请求都会被转发到这个服务。\n# frpc.toml [[proxies]] name = \"web01\" type = \"http\" localPort = 80 customDomains = [\"web.yourdomain.com\"] locations = [\"/\"] [[proxies]] name = \"web02\" type = \"http\" localPort = 81 customDomains = [\"web.yourdomain.com\"] locations = [\"/news\", \"/about\"] 按照上述的示例配置后，web.yourdomain.com 这个域名下所有以 /news 以及 /about 作为前缀的 URL 请求都会被转发到 web02，其余的请求会被转发到 web01。\n","categories":"","description":"","excerpt":"URL 路由 frp 支持根据请求的 URL 路径路由转发到不同的后端服务。\n通过配置文件中的 locations …","ref":"/zh-cn/docs/features/http-https/route/","tags":"","title":"路由"},{"body":"步骤 在具有公网 IP 的机器上部署 frps\n部署 frps 并编辑 frps.toml 文件。以下是简化的配置，其中设置了 frp 服务器用于接收客户端连接的端口：\nbindPort = 7000 在需要被访问的内网机器上部署 frpc\n部署 frpc 并编辑 frpc.toml 文件，假设 frps 所在服务器的公网 IP 地址为 x.x.x.x。以下是示例配置：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 localIP 和 localPort 配置为需要从公网访问的内网服务的地址和端口。 remotePort 表示在 frp 服务端监听的端口，访问此端口的流量将被转发到本地服务的相应端口。 启动 frps 和 frpc\n通过 SSH 访问内网机器\n使用以下命令通过 SSH 访问内网机器，假设用户名为 test：\nssh -o Port=6000 test@x.x.x.x frp 将请求发送到 x.x.x.x:6000 的流量转发到内网机器的 22 端口。\n","categories":"","description":"通过简单配置 TCP 类型的代理，使用户能够访问内网服务器。\n","excerpt":"通过简单配置 TCP 类型的代理，使用户能够访问内网服务器。\n","ref":"/zh-cn/docs/examples/ssh/","tags":"","title":"通过 SSH 访问内网机器"},{"body":"HTTPProxyPluginOptions Field Type Description Required type string Plugin type, set to “http_proxy”. Yes httpUser string HTTP proxy username. No httpPassword string HTTP proxy password. No Socks5PluginOptions Field Type Description Required type string Plugin type, set to “socks5”. Yes username string Username. No password string Password. No StaticFilePluginOptions Field Type Description Required type string Plugin type, set to “static_file”. Yes localPath string Local path where static files are located. Yes stripPrefix string Remove specific prefix from user HTTP request Path. No httpUser string HTTP Basic Auth username. No httpPassword string HTTP Basic Auth password. No UnixDomainSocketPluginOptions Field Type Description Required type string Plugin type, set to “unix_domain_socket”. Yes unixPath string UNIX domain socket address. Yes HTTP2HTTPSPluginOptions Field Type Description Required type string Plugin type, set to “http2https”. Yes localAddr string Local HTTPS service address. Yes hostHeaderRewrite string Replace Host header. No requestHeaders HeaderOperations Request Header operation configuration. No HTTPS2HTTPPluginOptions Field Type Description Required type string Plugin type, set to “https2http”. Yes localAddr string Local HTTPS service address. Yes hostHeaderRewrite string Replace Host header. No requestHeaders HeaderOperations Request Header operation configuration. No enableHTTP2 bool Whether to enable HTTP/2, enabled by default. No crtPath string TLS certificate file path. No keyPath string TLS key file path. No HTTPS2HTTPSPluginOptions Field Type Description Required type string Plugin type, set to “https2https”. Yes localAddr string Local HTTPS service address. Yes hostHeaderRewrite string Replace Host header. No requestHeaders HeaderOperations Request Header operation configuration. No enableHTTP2 bool Whether to enable HTTP/2, enabled by default. No crtPath string TLS certificate file path. No keyPath string TLS key file path. No TLS2RawPluginOptions Field Type Description Required type string Plugin type, set to “tls2raw”. Yes localAddr string Local service address. Yes crtPath string TLS certificate file path. No keyPath string TLS key file path. No VirtualNetPluginOptions Field Type Description Required type string Plugin type, set to “virtual_net”. Yes ","categories":"","description":"Detailed configuration description for frp client plugins.\n","excerpt":"Detailed configuration description for frp client plugins.\n","ref":"/en/docs/reference/client-plugin/","tags":"","title":"Client Plugin Configuration"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/reference/","tags":"","title":"Reference"},{"body":"frp supports routing connections received on a single port to different proxies, similar to vhostHTTPPort and vhostHTTPSPort.\nCurrently, the only supported multiplexer is httpconnect.\nWhen tcpmuxHTTPConnectPort is set in frps.toml, frps will listen on this port and accept HTTP CONNECT requests.\nfrps will route to different backend proxies based on the host in the HTTP CONNECT request.\nExample configuration:\n# frps.toml bindPort = 7000 tcpmuxHTTPConnectPort = 1337 # frpc.toml serverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"proxy1\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"test1\"] localPort = 80 [[proxies]] name = \"proxy2\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"test2\"] localPort = 8080 With the above configuration, if frps receives an HTTP CONNECT request:\nCONNECT test1 HTTP/1.1\\r\\n\\r\\n The connection will be routed to proxy1.\n","categories":"","description":"Learn about frp `TCPMUX` type proxies.\n","excerpt":"Learn about frp `TCPMUX` type proxies.\n","ref":"/en/docs/features/tcpmux/","tags":"","title":"TCPMUX"},{"body":"frp 支持将单个端口收到的连接路由到不同的代理，类似 vhostHTTPPort 和 vhostHTTPSPort。\n目前支持的复用器只有 httpconnect。\n当在 frps.toml 中设置 tcpmuxHTTPConnectPort，frps 将会监听在这个端口，接收 HTTP CONNECT 请求。\nfrps 会根据 HTTP CONNECT 请求中的 host 路由到不同的后端代理。\n示例配置如下：\n# frps.toml bindPort = 7000 tcpmuxHTTPConnectPort = 1337 # frpc.toml serverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"proxy1\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"test1\"] localPort = 80 [[proxies]] name = \"proxy2\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"test2\"] localPort = 8080 通过上面的配置，frps 如果接收到 HTTP CONNECT 请求内容:\nCONNECT test1 HTTP/1.1\\r\\n\\r\\n 该连接将会被路由到 proxy1 。\n","categories":"","description":"了解 frp `TCPMUX` 类型的代理。\n","excerpt":"了解 frp `TCPMUX` 类型的代理。\n","ref":"/zh-cn/docs/features/tcpmux/","tags":"","title":"TCPMUX"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh-cn/docs/reference/","tags":"","title":"参考"},{"body":"HTTPProxyPluginOptions Field Type Description Required type string 插件类型，设置为 “http_proxy”。 Yes httpUser string HTTP 代理用户名。 No httpPassword string HTTP 代理密码。 No Socks5PluginOptions Field Type Description Required type string 插件类型，设置为 “socks5”。 Yes username string 用户名。 No password string 密码。 No StaticFilePluginOptions Field Type Description Required type string 插件类型，设置为 “static_file”。 Yes localPath string 静态文件所在本地路径。 Yes stripPrefix string 去除用户 HTTP 请求 Path 的特定前缀。 No httpUser string HTTP Basic Auth 用户名。 No httpPassword string HTTP Basic Auth 密码。 No UnixDomainSocketPluginOptions Field Type Description Required type string 插件类型，设置为 “unix_domain_socket”。 Yes unixPath string UNIX 域套接字的地址。 Yes HTTP2HTTPSPluginOptions Field Type Description Required type string 插件类型，设置为 “http2https”。 Yes localAddr string 本地 HTTPS 服务地址。 Yes hostHeaderRewrite string 替换 Host header。 No requestHeaders HeaderOperations 对请求 Header 的操作配置。 No HTTPS2HTTPPluginOptions Field Type Description Required type string 插件类型，设置为 “https2http”。 Yes localAddr string 本地 HTTPS 服务地址。 Yes hostHeaderRewrite string 替换 Host header。 No requestHeaders HeaderOperations 对请求 Header 的操作配置。 No enableHTTP2 bool 是否启用 HTTP/2，默认启用。 No crtPath string TLS 证书文件路径。 No keyPath string TLS 密钥文件路径。 No HTTPS2HTTPSPluginOptions Field Type Description Required type string 插件类型，设置为 “https2https”。 Yes localAddr string 本地 HTTPS 服务地址。 Yes hostHeaderRewrite string 替换 Host header。 No requestHeaders HeaderOperations 对请求 Header 的操作配置。 No enableHTTP2 bool 是否启用 HTTP/2，默认启用。 No crtPath string TLS 证书文件路径。 No keyPath string TLS 密钥文件路径。 No TLS2RawPluginOptions Field Type Description Required type string 插件类型，设置为 “tls2raw”。 Yes localAddr string 本地服务地址。 Yes crtPath string TLS 证书文件路径。 No keyPath string TLS 密钥文件路径。 No VirtualNetPluginOptions Field Type Description Required type string 插件类型，设置为 “virtual_net”。 Yes ","categories":"","description":"frp 客户端插件的详细配置说明。\n","excerpt":"frp 客户端插件的详细配置说明。\n","ref":"/zh-cn/docs/reference/client-plugin/","tags":"","title":"客户端插件配置"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/docs/faq/","tags":"","title":"FAQ"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh-cn/docs/faq/","tags":"","title":"FAQ"},{"body":"VirtualNetVisitorPluginOptions Field Type Description Required type string Plugin type, set to “virtual_net”. Yes destinationIP string Target virtual IP address to access. Usually the server’s virtual network address. Yes ","categories":"","description":"Detailed configuration description for frp visitor plugins.\n","excerpt":"Detailed configuration description for frp visitor plugins.\n","ref":"/en/docs/reference/visitor-plugin/","tags":"","title":"Visitor Plugin Configuration"},{"body":"VirtualNetVisitorPluginOptions Field Type Description Required type string 插件类型，设置为 “virtual_net”。 Yes destinationIP string 要访问的目标虚拟 IP 地址。通常是服务端的虚拟网络地址。 Yes ","categories":"","description":"frp 访问者插件的详细配置说明。\n","excerpt":"frp 访问者插件的详细配置说明。\n","ref":"/zh-cn/docs/reference/visitor-plugin/","tags":"","title":"访问者插件配置"},{"body":"Starting from v0.52.0, frp began supporting TOML, YAML, and JSON as configuration file formats.\nPlease note that INI has been deprecated and will be removed in future releases. New features can only be used in TOML, YAML, or JSON. Users who wish to use these new features should switch their configuration format accordingly.\nFormat You can use any format you like among TOML/YAML/JSON to write configuration files, and frp will automatically adapt and parse them.\nDocumentation examples are mainly written in TOML. The following example configuration will penetrate local SSH services to the public network.\nfrps configuration:\nbindPort = 7000 frpc configuration:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 The same client can configure multiple proxies, but the name must be unique.\nBetween different clients, proxy name uniqueness can be ensured by configuring different user values.\nTemplate Rendering Configuration files support template rendering using environment variables, with template format adopting Go’s standard format.\nExample configuration:\nserverAddr = \"{{ .Envs.FRP_SERVER_ADDR }}\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = {{ .Envs.FRP_SSH_REMOTE_PORT }} Start frpc program:\nexport FRP_SERVER_ADDR=\"x.x.x.x\" export FRP_SSH_REMOTE_PORT=\"6000\" ./frpc -c ./frpc.toml frpc will automatically render configuration file templates using environment variables, with all environment variables requiring .Envs as a prefix.\nYAML Anchors and References frp supports YAML merge functionality (anchors and references, including dot-prefix fields), which works normally in strict configuration mode without using the --strict-config=false parameter.\nYou can use fields starting with dots as anchor definitions, similar to Docker Compose’s x- prefix:\n# frpc.yaml .common: \u0026common type: \"stcp\" secretKey: \"{{.Envs.FRPC_SECRET_KEY}}\" localIP: \"127.0.0.1\" serverAddr: \"x.x.x.x\" serverPort: 7000 proxies: - name: \"ssh\" localPort: 22 \u003c\u003c: *common - name: \"web\" localPort: 80 \u003c\u003c: *common Configuration Validation You can validate configuration file parameters in advance by executing frpc verify -c ./frpc.toml or frps verify -c ./frps.toml.\nfrpc: the configuration file ./frpc.toml syntax is ok If this result appears, it means there are no errors in the new configuration file, otherwise specific error information will be output.\nStrict Mode Validation By default, frp uses strict mode for configuration validation. If you need to disable strict validation, you can use the --strict-config=false parameter:\nfrpc verify -c ./frpc.yaml --strict-config=false Configuration Splitting Through the includes parameter, you can include other configuration files in the main configuration, thus implementing the management of proxy configurations split across multiple files.\n# frpc.toml serverAddr = \"x.x.x.x\" serverPort = 7000 includes = [\"./confd/*.toml\"] # ./confd/test.toml [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 The above configuration additionally includes proxy configuration content from all toml files in the ./confd directory through includes in frpc.toml, which is equivalent to merging these two files into one.\nNote that files specified by includes can only contain proxy configurations, and common parameter configurations can only be placed in the main configuration file.\nComplete Configuration Parameters Since frp currently supports many features and configuration items, feature parameters not listed in the documentation can be viewed in Reference.\n","categories":"","description":"","excerpt":"Starting from v0.52.0, frp began supporting TOML, YAML, and JSON as …","ref":"/en/docs/features/common/configure/","tags":"","title":"Configuration File"},{"body":"Steps Deploy frps on a machine with public IP\nModify the frps.toml file to include the following content (using the most simplified configuration here):\nbindPort = 7000 tcpmuxHTTPConnectPort = 5002 Deploy frpc on intranet machine A\nCreate an frpc configuration file, for example frpc.toml, and add the following content to the configuration file:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh1\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"machine-a.example.com\"] localIP = \"127.0.0.1\" localPort = 22 Deploy another frpc on intranet machine B\nCreate an frpc configuration file, for example frpc.toml, and add the following content to the configuration file:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh2\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"machine-b.example.com\"] localIP = \"127.0.0.1\" localPort = 22 Access intranet machine A via SSH ProxyCommand\nUse SSH ProxyCommand to access intranet machine A, assuming the username is test. Use the following command:\nssh -o 'proxycommand socat - PROXY:x.x.x.x:%h:%p,proxyport=5002' test@machine-a.example.com To access intranet machine B, simply change the domain name, assuming the username is still test:\nssh -o 'proxycommand socat - PROXY:x.x.x.x:%h:%p,proxyport=5002' test@machine-b.example.com By following the above steps, you can implement multiple SSH services sharing the same port for access on machines with public IP addresses.\n","categories":"","description":"By using tcpmux type proxy, you can expose multiple SSH services through the same port. This method is also suitable for any client that supports HTTP Connect proxy connection method to achieve port multiplexing.\n","excerpt":"By using tcpmux type proxy, you can expose multiple SSH services …","ref":"/en/docs/examples/multiple-ssh-over-same-port/","tags":"","title":"Multiple SSH Services Sharing the Same Port"},{"body":"Sponsors frp is an open source project with its ongoing development made possible entirely by the support of our awesome sponsors.\nIf you’d like to join them, please consider sponsoring frp’s development.\nGold Sponsors Recall.ai - API for meeting recordings\nIf you're looking for a meeting recording API, consider checking out Recall.ai, an API that records Zoom, Google Meet, Microsoft Teams, in-person meetings, and more. Requestly - Free \u0026 Open-Source alternative to Postman All-in-one platform to Test, Mock and Intercept APIs. Warp, built for collaborating with AI Agents Available for macOS, Linux and Windows The complete IDE crafted for professional Go developers Secure and Elastic Infrastructure for Running Your AI-Generated Code The sovereign cloud that puts you in control ","categories":"","description":"Thank you to our sponsors for supporting the frp project\n","excerpt":"Thank you to our sponsors for supporting the frp project\n","ref":"/en/sponsors/","tags":"","title":"Sponsors"},{"body":"步骤 在具有公网 IP 的机器上部署 frps\n修改 frps.toml 文件以包含以下内容（这里使用了最简化的配置）：\nbindPort = 7000 tcpmuxHTTPConnectPort = 5002 在内网机器 A 上部署 frpc\n创建 frpc 配置文件，例如 frpc.toml，然后将以下内容添加到配置文件中：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh1\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"machine-a.example.com\"] localIP = \"127.0.0.1\" localPort = 22 在内网机器 B 上部署另一个 frpc\n创建 frpc 配置文件，例如 frpc.toml，然后将以下内容添加到配置文件中：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh2\" type = \"tcpmux\" multiplexer = \"httpconnect\" customDomains = [\"machine-b.example.com\"] localIP = \"127.0.0.1\" localPort = 22 通过 SSH ProxyCommand 访问内网机器 A\n使用 SSH ProxyCommand 访问内网机器 A，假设用户名为 test。使用以下命令：\nssh -o 'proxycommand socat - PROXY:x.x.x.x:%h:%p,proxyport=5002' test@machine-a.example.com 要访问内网机器 B，只需更改域名，假设用户名仍然为 test：\nssh -o 'proxycommand socat - PROXY:x.x.x.x:%h:%p,proxyport=5002' test@machine-b.example.com 通过按照以上步骤进行配置，您可以实现多个 SSH 服务复用同一端口，以便在具有公网 IP 的机器上进行访问。\n","categories":"","description":"通过使用 tcpmux 类型的代理，您可以实现多个 SSH 服务通过同一端口进行暴露。这种方法还适用于任何支持 HTTP Connect 代理连接方式的客户端，以实现端口的复用。\n","excerpt":"通过使用 tcpmux 类型的代理，您可以实现多个 SSH 服务通过同一端口进行暴露。这种方法还适用于任何支持 HTTP Connect 代 …","ref":"/zh-cn/docs/examples/multiple-ssh-over-same-port/","tags":"","title":"多个 SSH 服务复用同一端口"},{"body":"赞助商 frp 是一个开源项目，其持续开发完全依赖于我们出色的赞助商们的支持。\n如果您想加入他们的行列，请考虑赞助 frp 的开发。\n金牌赞助商 Recall.ai - 会议录制 API\n如果你正在寻找会议录制的 API，不妨了解一下 Recall.ai。它支持录制 Zoom、Google Meet、Microsoft Teams 以及线下会议等更多场景。 Requestly - Postman 的免费开源替代品 测试、模拟和拦截 API 的一体化平台 Warp——为与 AI 智能体协作而生 适用于 macOS、Linux 和 Windows 为专业 Go 开发者打造的 IDE 运行 AI 生成代码的安全弹性基础设施 开源个人云，助你重新掌控数据 ","categories":"","description":"感谢我们的赞助商对 frp 项目的支持\n","excerpt":"感谢我们的赞助商对 frp 项目的支持\n","ref":"/zh-cn/sponsors/","tags":"","title":"赞助商"},{"body":"从 v0.52.0 版本开始，frp 开始支持 TOML、YAML 和 JSON 作为配置文件格式。\n请注意，INI 已被弃用，并将在未来的发布中移除。新功能只能在TOML、YAML 或 JSON 中使用。希望使用这些新功能的用户应相应地切换其配置格式。\n格式 可使用 TOML/YAML/JSON 任何一个您喜欢的格式来编写配置文件，frp 会自动适配进行解析。\n文档示例主要通过 TOML 编写，如下的示例配置将本地 SSH 服务穿透到公网。\nfrps 配置：\nbindPort = 7000 frpc 配置：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 同一个客户端可以配置多个代理，但是 name 必须确保唯一。\n不同的客户端之间，可以通过配置不同的 user 来确保代理名称唯一。\n模版渲染 配置文件支持使用环境变量进行模版渲染，模版格式采用 Go 的标准格式。\n示例配置如下：\nserverAddr = \"{{ .Envs.FRP_SERVER_ADDR }}\" serverPort = 7000 [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = {{ .Envs.FRP_SSH_REMOTE_PORT }} 启动 frpc 程序：\nexport FRP_SERVER_ADDR=\"x.x.x.x\" export FRP_SSH_REMOTE_PORT=\"6000\" ./frpc -c ./frpc.toml frpc 会自动使用环境变量渲染配置文件模版，所有环境变量需要以 .Envs 为前缀。\nYAML 锚点和引用 frp 支持 YAML 合并功能（锚点和引用，包括点前缀字段），在严格配置模式下无需使用 --strict-config=false 参数即可正常工作。\n可以使用以点开头的字段作为锚点定义，类似于 Docker Compose 的 x- 前缀：\n# frpc.yaml .common: \u0026common type: \"stcp\" secretKey: \"{{.Envs.FRPC_SECRET_KEY}}\" localIP: \"127.0.0.1\" serverAddr: \"x.x.x.x\" serverPort: 7000 proxies: - name: \"ssh\" localPort: 22 \u003c\u003c: *common - name: \"web\" localPort: 80 \u003c\u003c: *common 配置校验 通过执行 frpc verify -c ./frpc.toml 或 frps verify -c ./frps.toml 可以对配置文件中的参数进行预先校验。\nfrpc: the configuration file ./frpc.toml syntax is ok 如果出现此结果，则说明新的配置文件没有错误，否则会输出具体的错误信息。\n严格模式校验 默认情况下，frp 使用严格模式进行配置校验。如果需要禁用严格校验，可以使用 --strict-config=false 参数：\nfrpc verify -c ./frpc.yaml --strict-config=false 配置拆分 通过 includes 参数可以在主配置中包含其他配置文件，从而实现将代理配置拆分到多个文件中管理。\n# frpc.toml serverAddr = \"x.x.x.x\" serverPort = 7000 includes = [\"./confd/*.toml\"] # ./confd/test.toml [[proxies]] name = \"ssh\" type = \"tcp\" localIP = \"127.0.0.1\" localPort = 22 remotePort = 6000 上述配置在 frpc.toml 中通过 includes 额外包含了 ./confd 目录下所有的 toml 文件的代理配置内容，效果等价于将这两个文件合并成一个文件。\n需要注意的是 includes 指定的文件中只能包含代理配置，通用参数的配置只能放在主配置文件中。\n完整配置参数 由于 frp 目前支持的功能和配置项较多，未在文档中列出的功能参数可以在 参考 中查看。\n","categories":"","description":"","excerpt":"从 v0.52.0 版本开始，frp 开始支持 TOML、YAML 和 JSON 作为配置文件格式。\n请注意，INI 已被弃用，并将在未来的 …","ref":"/zh-cn/docs/features/common/configure/","tags":"","title":"配置文件"},{"body":"HTTP type proxies are very suitable for providing intranet web services to external users through custom domain names. Compared to TCP type proxies, HTTP proxies can not only reuse ports but also provide many features based on the HTTP protocol.\nHTTPS is similar to this, but it should be noted that frp’s HTTPS proxy requires the local service to be an HTTPS service, and frps will not perform TLS termination. You can also combine the https2http plugin to expose local HTTP services through the HTTPS protocol.\nSteps Configure frps.toml\nAdd the following content to the frps.toml file to specify the listening port for HTTP requests as 8080:\nbindPort = 7000 vhostHTTPPort = 8080 If you need to configure HTTPS proxy, you also need to set vhostHTTPSPort.\nConfigure frpc.toml\nAdd the following content to the frpc.toml file, ensuring the correct server IP address, local web service listening port, and custom domain name are set:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"www.yourdomain.com\"] [[proxies]] name = \"web2\" type = \"http\" localPort = 8080 customDomains = [\"www.yourdomain2.com\"] Start frps and frpc\nDomain Name Resolution\nResolve the A records of www.yourdomain.com and www.yourdomain2.com to the server’s IP address x.x.x.x. If the server already has a corresponding domain name, you can also resolve CNAME records to the original domain name. Additionally, the same effect can be achieved by modifying the Host field of HTTP requests.\nAccess via Browser\nUse a browser to access http://www.yourdomain.com:8080 to access the port 80 service on the intranet machine, and access http://www.yourdomain2.com:8080 to access the port 8080 service on the intranet machine.\n","categories":"","description":"Through simple configuration of HTTP type proxy, you can allow users to access intranet web services through custom domain names.\n","excerpt":"Through simple configuration of HTTP type proxy, you can allow users …","ref":"/en/docs/examples/vhost-http/","tags":"","title":"Access Intranet Web Services via Custom Domain Names"},{"body":"HTTP 类型的代理非常适合将内网的 Web 服务通过自定义域名提供给外部用户。相比于 TCP 类型代理，HTTP 代理不仅可以复用端口，还提供了基于 HTTP 协议的许多功能。\nHTTPS 与此类似，但是需要注意，frp 的 https 代理需要本地服务是 HTTPS 服务，frps 端不会做 TLS 终止。也可以结合 https2http 插件来实现将本地的 HTTP 服务以 HTTPS 协议暴露出去。\n步骤 配置 frps.toml\n在 frps.toml 文件中添加以下内容，以指定 HTTP 请求的监听端口为 8080：\nbindPort = 7000 vhostHTTPPort = 8080 如果需要配置 HTTPS 代理，还需要设置 vhostHTTPSPort。\n配置 frpc.toml\n在 frpc.toml 文件中添加以下内容，确保设置了正确的服务器 IP 地址、本地 Web 服务监听端口和自定义域名：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"web\" type = \"http\" localPort = 80 customDomains = [\"www.yourdomain.com\"] [[proxies]] name = \"web2\" type = \"http\" localPort = 8080 customDomains = [\"www.yourdomain2.com\"] 启动 frps 和 frpc\n域名解析\n将 www.yourdomain.com 和 www.yourdomain2.com 的域名 A 记录解析到服务器的 IP 地址 x.x.x.x。如果服务器已经有对应的域名，您还可以将 CNAME 记录解析到原始域名。另外，通过修改 HTTP 请求的 Host 字段也可以实现相同的效果。\n通过浏览器访问\n使用浏览器访问 http://www.yourdomain.com:8080 即可访问内网机器上的 80 端口服务，访问 http://www.yourdomain2.com:8080 可以访问内网机器上的 8080 端口服务。\n","categories":"","description":"通过简单配置 HTTP 类型的代理，您可以让用户通过自定义域名访问内网的 Web 服务。\n","excerpt":"通过简单配置 HTTP 类型的代理，您可以让用户通过自定义域名访问内网的 Web 服务。\n","ref":"/zh-cn/docs/examples/vhost-http/","tags":"","title":"通过自定义域名访问内网的 Web 服务"},{"body":"Learn how to deploy and use frp.\n","categories":"","description":"","excerpt":"Learn how to deploy and use frp.\n","ref":"/en/docs/","tags":"","title":"Documentation"},{"body":"DNS query requests typically use the UDP protocol, and frp supports penetration of intranet UDP services, with configuration similar to TCP.\nSteps Configure frps.toml\nAdd the following content to the frps.toml file:\nbindPort = 7000 Configure frpc.toml\nAdd the following content to the frpc.toml file:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"dns\" type = \"udp\" localIP = \"8.8.8.8\" localPort = 53 remotePort = 6000 Please note that this example reverse-proxies Google’s DNS query server address, which is only for testing UDP proxy and has no practical significance.\nStart frps and frpc\nStart frps and frpc respectively.\nTest DNS Query Requests\nUse the following command to test UDP packet forwarding with the dig tool, expecting to return the resolution result for the www.baidu.com domain:\ndig @x.x.x.x -p 6000 www.baidu.com ","categories":"","description":"This example demonstrates how to forward DNS query requests through simple configuration of UDP type proxy.\n","excerpt":"This example demonstrates how to forward DNS query requests through …","ref":"/en/docs/examples/dns/","tags":"","title":"Forward DNS Query Requests"},{"body":"Currently, frps server supports two monitoring systems: memory monitoring and Prometheus monitoring.\nMemory Monitoring Monitoring data stored in memory is primarily used for Dashboard display. When the Dashboard feature is enabled in frps configuration, memory monitoring is enabled by default.\nPlease note that monitoring data in memory will be cleared after each process restart, or retained for 7 days. Monitoring data can be obtained by sending HTTP requests to the Dashboard address, but this API is not currently standardized and direct use is not recommended.\nPrometheus Monitoring Due to design issues, the query interface provided by Prometheus to the outside world shares the same address as the Dashboard, so to use Prometheus monitoring, you must first enable the Dashboard.\nEnable Dashboard in frps.ini and set enablePrometheus = true, then you can access http://{dashboard_addr}/metrics to get Prometheus monitoring data.\n","categories":"","description":"","excerpt":"Currently, frps server supports two monitoring systems: memory …","ref":"/en/docs/features/common/monitor/","tags":"","title":"Monitoring"},{"body":"目前，frps 服务端支持两种监控系统：内存监控和 Prometheus 监控。\n内存监控 内存中存储的监控数据主要用于 Dashboard 展示。当在 frps 配置中开启 Dashboard 功能后，内存监控默认启用。\n请注意，内存中的监控数据在每次重启进程后会被清空，或者保留 7 天。监控数据可以通过 Dashboard 的地址发送 HTTP 请求获取，但目前此 API 尚不规范，不建议直接使用。\nPrometheus 监控 由于设计问题，Prometheus 对外提供的查询接口与 Dashboard 的地址重用，因此要使用 Prometheus 监控，必须首先启用 Dashboard。\n在 frps.ini 中启用 Dashboard 并设置 enablePrometheus = true，然后你可以通过访问 http://{dashboard_addr}/metrics 来获取 Prometheus 的监控数据。\n","categories":"","description":"","excerpt":"目前，frps 服务端支持两种监控系统：内存监控和 Prometheus 监控。\n内存监控 内存中存储的监控数据主要用于 Dashboard …","ref":"/zh-cn/docs/features/common/monitor/","tags":"","title":"监控"},{"body":"DNS 查询请求通常使用 UDP 协议，而 frp 支持对内网 UDP 服务的穿透，配置方式与 TCP 类似。\n步骤 配置 frps.toml\n在 frps.toml 文件中添加以下内容：\nbindPort = 7000 配置 frpc.toml\n在 frpc.toml 文件中添加以下内容：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"dns\" type = \"udp\" localIP = \"8.8.8.8\" localPort = 53 remotePort = 6000 请注意，这里示例中反代了 Google 的 DNS 查询服务器的地址，仅用于测试 UDP 代理，并没有实际意义。\n启动 frps 和 frpc\n分别启动 frps 和 frpc。\n测试 DNS 查询请求\n使用以下命令通过 dig 工具测试 UDP 包转发是否成功，预期会返回 www.baidu.com 域名的解析结果：\ndig @x.x.x.x -p 6000 www.baidu.com ","categories":"","description":"本示例演示如何通过简单配置 UDP 类型的代理来实现 DNS 查询请求的转发。\n","excerpt":"本示例演示如何通过简单配置 UDP 类型的代理来实现 DNS 查询请求的转发。\n","ref":"/zh-cn/docs/examples/dns/","tags":"","title":"转发 DNS 查询请求"},{"body":"Steps Configure frps.toml\nAdd the following content to the frps.toml file:\nbindPort = 7000 Configure frpc.toml\nAdd the following content to the frpc.toml file, ensuring the correct Unix domain socket path is set:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"unix_domain_socket\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"unix_domain_socket\" # Unix domain socket path unixPath = \"/var/run/docker.sock\" Start frps and frpc\nUse curl to view Docker version information\ncurl http://x.x.x.x:6000/version ","categories":"","description":"By configuring the Unix domain socket client plugin, you can use TCP ports to access intranet Unix domain socket services, such as Docker Daemon.\n","excerpt":"By configuring the Unix domain socket client plugin, you can use TCP …","ref":"/en/docs/examples/unix-domain-socket/","tags":"","title":"Forward Unix Domain Socket"},{"body":"步骤 配置 frps.toml\n在 frps.toml 文件中添加以下内容：\nbindPort = 7000 配置 frpc.toml\n在 frpc.toml 文件中添加以下内容，确保设置正确的 Unix 域套接字路径：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"unix_domain_socket\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"unix_domain_socket\" # Unix 域套接字路径 unixPath = \"/var/run/docker.sock\" 启动 frps 和 frpc\n使用 curl 查看 Docker 版本信息\ncurl http://x.x.x.x:6000/version ","categories":"","description":"通过配置 Unix 域套接字客户端插件，您可以使用 TCP 端口访问内网的 Unix 域套接字服务，例如 Docker Daemon。\n","excerpt":"通过配置 Unix 域套接字客户端插件，您可以使用 TCP 端口访问内网的 Unix 域套接字服务，例如 Docker Daemon。\n","ref":"/zh-cn/docs/examples/unix-domain-socket/","tags":"","title":"转发 Unix 域套接字"},{"body":"Currently, frpc and frps support two authentication methods: token and oidc, with token being the default. These authentication methods allow you to verify communication between the client and server, ensuring that only authorized users can establish connections.\nToken Token authentication is a simple authentication method that only requires configuring the same token in both the frp client (frpc) and server (frps) configuration files.\nConfiguration Example # frps.toml bindPort = 7000 auth.token = \"abc\" # frpc.toml auth.token = \"abc\" Loading Token from File Added in v0.64.0\nfrp supports using tokenSource to load authentication tokens from files instead of hardcoding them in configuration files. This feature helps avoid exposing sensitive information directly in configuration files.\nConfiguration The tokenSource field is mutually exclusive with the token field - you can only use one of them.\nServer configuration example:\n# frps.toml bindPort = 7000 auth.tokenSource.type = \"file\" auth.tokenSource.file.path = \"/etc/frp/server_token\" Client configuration example:\n# frpc.toml auth.tokenSource.type = \"file\" auth.tokenSource.file.path = \"/etc/frp/client_token\" Important Notes Token files should have appropriate permissions (e.g., 600) to ensure only the user running frp can read them Tokens in files will have leading and trailing whitespace automatically trimmed tokenSource is resolved at configuration load time and does not support runtime dynamic reloading Loading Token from External Command Added in v0.66.0\nIn addition to reading tokens from files, frp also supports obtaining tokens dynamically by executing external commands. This is useful when integrating with cloud service CLIs or secret management systems.\nConfiguration Client configuration example:\n# frpc.toml auth.tokenSource.type = \"exec\" auth.tokenSource.exec.command = \"/usr/bin/get-token\" auth.tokenSource.exec.args = [\"--format\", \"raw\"] auth.tokenSource.exec.env = [ { name = \"TOKEN_SERVICE\", value = \"production\" } ] Security Notes For security reasons, the exec type tokenSource requires the --allow-unsafe=TokenSourceExec flag when starting frpc.\nfrpc -c frpc.toml --allow-unsafe=TokenSourceExec OIDC (OpenID Connect) Authentication OIDC authentication is an open standard-based authentication method that uses OIDC providers for identity verification.\nThe verification process follows Client Credentials Grant.\nConfiguration Example # frps.toml auth.method = \"oidc\" auth.oidc.issuer = \"https://example-oidc-issuer.com/\" auth.oidc.audience = \"https://oidc-audience.com/.default\" # frpc.toml auth.method = \"oidc\" auth.oidc.clientID = \"98692467-37de-409a-9fac-bb2585826f18\" auth.oidc.clientSecret = \"oidc_secret\" auth.oidc.audience = \"https://oidc-audience.com/.default\" auth.oidc.tokenEndpointURL = \"https://example-oidc-endpoint.com/oauth2/v2.0/token\" ","categories":"","description":"","excerpt":"Currently, frpc and frps support two authentication methods: token and …","ref":"/en/docs/features/common/authentication/","tags":"","title":"Authentication"},{"body":"By using the static_file plugin, you can easily provide an HTTP-based file access service that allows others to access your specified files.\nSteps Configure frps.toml\nAdd the following content to the frps.toml file:\nbindPort = 7000 Configure frpc.toml\nAdd the following content to the frpc.toml file, ensuring appropriate file paths, username, and password are set:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"test_static_file\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"static_file\" # Local file directory to provide external access localPath = \"/tmp/file\" # Prefix in URL that will be removed, remaining content is the file path to access stripPrefix = \"static\" httpUser = \"abc\" httpPassword = \"abc\" Please modify localPath, stripPrefix, httpUser, and httpPassword according to your actual situation.\nStart frps and frpc\nAccess Files via Browser\nUse a browser to visit http://x.x.x.x:6000/static/ to view files located in the /tmp/file directory. The system will require you to enter the username and password you set.\n","categories":"","description":"By configuring the `static_file` client plugin, you can expose local files on the public network for others to access.\n","excerpt":"By configuring the `static_file` client plugin, you can expose local …","ref":"/en/docs/examples/static-file/","tags":"","title":"Provide Simple File Access Service"},{"body":"通过使用 static_file 插件，您可以轻松地提供一个基于 HTTP 的文件访问服务，让其他人可以访问您指定的文件。\n步骤 配置 frps.toml\n在 frps.toml 文件中添加以下内容：\nbindPort = 7000 配置 frpc.toml\n在 frpc.toml 文件中添加以下内容，确保设置合适的文件路径、用户名和密码：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"test_static_file\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"static_file\" # 本地文件目录，对外提供访问 localPath = \"/tmp/file\" # URL 中的前缀，将被去除，保留的内容即为要访问的文件路径 stripPrefix = \"static\" httpUser = \"abc\" httpPassword = \"abc\" 请根据实际情况修改 localPath、stripPrefix、httpUser 和 httpPassword。\n启动 frps 和 frpc\n通过浏览器访问文件\n使用浏览器访问 http://x.x.x.x:6000/static/，以查看位于 /tmp/file 目录下的文件。系统会要求输入您设置的用户名和密码。\n","categories":"","description":"通过配置 `static_file` 客户端插件，您可以将本地文件暴露在公网上，以供其他人访问。\n","excerpt":"通过配置 `static_file` 客户端插件，您可以将本地文件暴露在公网上，以供其他人访问。\n","ref":"/zh-cn/docs/examples/static-file/","tags":"","title":"对外提供简单的文件访问服务"},{"body":"目前 frpc 和 frps 之间支持两种身份验证方式，token 和 oidc，默认为 token。这些认证方式允许您验证客户端与服务端之间的通信，并确保只有授权用户能够建立连接。\nToken Token 身份认证是一种简单的身份认证方式，只需要在 frp 的客户端 frpc 和服务端 frps 配置文件中配置相同的 token 即可。\n配置示例 # frps.toml bindPort = 7000 auth.token = \"abc\" # frpc.toml auth.token = \"abc\" 从文件加载 Token Added in v0.64.0\nfrp 支持使用 tokenSource 从文件中加载认证 token，而不是在配置文件中硬编码。这个功能可以避免在配置文件中直接暴露敏感信息。\n配置方式 tokenSource 与 token 字段互斥，只能选择其中一种方式配置。\n服务端配置示例：\n# frps.toml bindPort = 7000 auth.tokenSource.type = \"file\" auth.tokenSource.file.path = \"/etc/frp/server_token\" 客户端配置示例：\n# frpc.toml auth.tokenSource.type = \"file\" auth.tokenSource.file.path = \"/etc/frp/client_token\" 注意事项 token 文件应该设置适当的权限（如 600），确保只有运行 frp 的用户可以读取 文件中的 token 会自动去除首尾空白字符 tokenSource 在配置加载时解析，不支持运行时动态重新加载 通过外部命令获取 Token Added in v0.66.0\n除了从文件读取 token，frp 还支持通过执行外部命令来动态获取 token。这在需要与云服务 CLI 或密钥管理系统集成时非常有用。\n配置方式 客户端配置示例：\n# frpc.toml auth.tokenSource.type = \"exec\" auth.tokenSource.exec.command = \"/usr/bin/get-token\" auth.tokenSource.exec.args = [\"--format\", \"raw\"] auth.tokenSource.exec.env = [ { name = \"TOKEN_SERVICE\", value = \"production\" } ] 安全注意事项 出于安全考虑，exec 类型的 tokenSource 需要在启动 frpc 时添加 --allow-unsafe=TokenSourceExec 参数才能启用。\nfrpc -c frpc.toml --allow-unsafe=TokenSourceExec OIDC (OpenID Connect) 身份认证 OIDC 身份认证是一种基于开放标准的身份认证方式，它通过使用 OIDC 提供者进行身份验证。\n验证流程参考 Client Credentials Grant。\n配置示例 # frps.toml auth.method = \"oidc\" auth.oidc.issuer = \"https://example-oidc-issuer.com/\" auth.oidc.audience = \"https://oidc-audience.com/.default\" # frpc.toml auth.method = \"oidc\" auth.oidc.clientID = \"98692467-37de-409a-9fac-bb2585826f18\" auth.oidc.clientSecret = \"oidc_secret\" auth.oidc.audience = \"https://oidc-audience.com/.default\" auth.oidc.tokenEndpointURL = \"https://example-oidc-endpoint.com/oauth2/v2.0/token\" ","categories":"","description":"","excerpt":"目前 frpc 和 frps 之间支持两种身份验证方式，token 和 oidc，默认为 token。这些认证方式允许您验证客户端与服务端之 …","ref":"/zh-cn/docs/features/common/authentication/","tags":"","title":"身份认证"},{"body":"Steps Configure frps.toml\nbindPort = 7000 vhostHTTPSPort = 443 Configure frpc.toml\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"test_htts2http\" type = \"https\" customDomains = [\"test.yourdomain.com\"] [proxies.plugin] type = \"https2http\" localAddr = \"127.0.0.1:80\" # HTTPS certificate related configuration crtPath = \"./server.crt\" keyPath = \"./server.key\" hostHeaderRewrite = \"127.0.0.1\" requestHeaders.set.x-from-where = \"frp\" Please note that you need to modify the above configuration according to your domain name and certificate path.\nStart frps and frpc\nAccess HTTPS Service\nOpen your web browser and visit https://test.yourdomain.com.\nBy following the above steps, you will be able to enable HTTPS for local HTTP services to achieve secure external access.\n","categories":"","description":"Use the `https2http` plugin to convert local HTTP services to HTTPS services for external access.\n","excerpt":"Use the `https2http` plugin to convert local HTTP services to HTTPS …","ref":"/en/docs/examples/https2http/","tags":"","title":"Enable HTTPS for Local HTTP Service"},{"body":"步骤 配置 frps.toml\nbindPort = 7000 vhostHTTPSPort = 443 配置 frpc.toml\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"test_htts2http\" type = \"https\" customDomains = [\"test.yourdomain.com\"] [proxies.plugin] type = \"https2http\" localAddr = \"127.0.0.1:80\" # HTTPS 证书相关的配置 crtPath = \"./server.crt\" keyPath = \"./server.key\" hostHeaderRewrite = \"127.0.0.1\" requestHeaders.set.x-from-where = \"frp\" 请注意，您需要根据您的域名和证书路径自行更改上述配置。\n启动 frps 和 frpc\n访问 HTTPS 服务\n打开您的 Web 浏览器，访问 https://test.yourdomain.com。\n通过按照以上步骤进行配置，您将能够为本地 HTTP 服务启用 HTTPS，以实现安全的外部访问。\n","categories":"","description":"使用 `https2http` 插件将本地 HTTP 服务转换为 HTTPS 服务，以供外部访问。\n","excerpt":"使用 `https2http` 插件将本地 HTTP 服务转换为 HTTPS 服务，以供外部访问。\n","ref":"/zh-cn/docs/examples/https2http/","tags":"","title":"为本地 HTTP 服务启用 HTTPS"},{"body":"Some intranet services may pose security risks if directly exposed on the public network. Using stcp (secret tcp) type proxies allows you to securely expose intranet services to authorized users, which requires visitors to also deploy frpc clients.\nSteps Configure frps.toml\nAdd the following content to the frps.toml file:\nbindPort = 7000 Deploy frpc client and configure\nDeploy frpc on the machine that needs to expose intranet services to the public network, and create the following configuration:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"secret_ssh\" type = \"stcp\" # Only users with the same secretKey as set here can access this service secretKey = \"abcdefg\" localIP = \"127.0.0.1\" localPort = 22 Deploy and configure frpc on the visitor machine\nAlso deploy frpc on the machine that wants to access the intranet service, and create the following configuration:\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[visitors]] name = \"secret_ssh_visitor\" type = \"stcp\" # Name of the stcp proxy to access serverName = \"secret_ssh\" secretKey = \"abcdefg\" # Bind local port to access SSH service bindAddr = \"127.0.0.1\" bindPort = 6000 Access the intranet machine via SSH\nUse the following command to access the intranet machine via SSH, assuming the username is test:\nssh -o Port=6000 test@127.0.0.1 ","categories":"","description":"By creating an SSH service proxy that only authorized users can access, achieve secure exposure of intranet services.\n","excerpt":"By creating an SSH service proxy that only authorized users can …","ref":"/en/docs/examples/stcp/","tags":"","title":"Securely Expose Intranet Services"},{"body":"Currently, frpc and frps have built-in corresponding web interfaces for user convenience.\nServer Dashboard The server Dashboard allows users to view frp status and proxy statistics through a browser.\nNote: Dashboard has not been optimized for displaying large amounts of proxy data. If you experience slow Dashboard access, please do not enable this feature.\nYou need to specify the port used by the dashboard service in frps.toml to enable this feature:\n# Default is 127.0.0.1, if you need public network access, change to 0.0.0.0. webServer.addr = \"0.0.0.0\" webServer.port = 7500 # dashboard username and password, optional, default is empty webServer.user = \"admin\" webServer.password = \"admin\" Open your browser and access the Dashboard interface through http://[server addr]:7500, enter username and password admin.\nYou can also enable HTTPS interface by configuring TLS certificates:\nwebServer.tls.certFile = \"server.crt\" webServer.tls.keyFile = \"server.key\" Client Management Interface The built-in Admin UI in frpc can help users query and manage client proxy status and configuration through a browser.\nYou need to specify the port used by the admin service in frpc.toml to enable this feature:\n# frpc.toml webServer.addr = \"127.0.0.1\" webServer.port = 7400 webServer.user = \"admin\" webServer.password = \"admin\" Open your browser and access the Admin UI through http://127.0.0.1:7400.\nIf you want to access the Admin UI from an external network environment, you can map port 7400 through frp, but you need to pay attention to security risks.\n# frpc.toml [[proxies]] name = \"admin_ui\" type = \"tcp\" localPort = 7400 remotePort = 7400 ","categories":"","description":"","excerpt":"Currently, frpc and frps have built-in corresponding web interfaces …","ref":"/en/docs/features/common/ui/","tags":"","title":"Web Interface"},{"body":"目前 frpc 和 frps 分别内置了相应的 Web 界面方便用户使用。\n服务端 Dashboard 服务端 Dashboard 使用户可以通过浏览器查看 frp 的状态以及代理统计信息。\n注：Dashboard 尚未针对大量的 proxy 数据展示做优化，如果出现 Dashboard 访问较慢的情况，请不要启用此功能。\n需要在 frps.toml 中指定 dashboard 服务使用的端口，即可开启此功能：\n# 默认为 127.0.0.1，如果需要公网访问，需要修改为 0.0.0.0。 webServer.addr = \"0.0.0.0\" webServer.port = 7500 # dashboard 用户名密码，可选，默认为空 webServer.user = \"admin\" webServer.password = \"admin\" 打开浏览器通过 http://[server addr]:7500 访问 Dashboard 界面，输入用户名密码 admin。\n你也可以通过配置 TLS 证书来启用 HTTPS 接口:\nwebServer.tls.certFile = \"server.crt\" webServer.tls.keyFile = \"server.key\" 客户端管理界面 frpc 内置的 Admin UI 可以帮助用户通过浏览器来查询和管理客户端的 proxy 状态和配置。\n需要在 frpc.toml 中指定 admin 服务使用的端口，即可开启此功能：\n# frpc.toml webServer.addr = \"127.0.0.1\" webServer.port = 7400 webServer.user = \"admin\" webServer.password = \"admin\" 打开浏览器通过 http://127.0.0.1:7400 访问 Admin UI。\n如果想要在外网环境访问 Admin UI，可以将 7400 端口通过 frp 映射出去即可，但需要重视安全风险。\n# frpc.toml [[proxies]] name = \"admin_ui\" type = \"tcp\" localPort = 7400 remotePort = 7400 ","categories":"","description":"","excerpt":"目前 frpc 和 frps 分别内置了相应的 Web 界面方便用户使用。\n服务端 Dashboard 服务端 Dashboard 使用户可 …","ref":"/zh-cn/docs/features/common/ui/","tags":"","title":"Web 界面"},{"body":"某些内网服务，如果直接暴露在公网上，可能存在安全风险。使用 stcp(secret tcp) 类型的代理可以让您安全地将内网服务暴露给经过授权的用户，这需要访问者也部署 frpc 客户端。\n步骤 配置 frps.toml\n在 frps.toml 文件中添加以下内容：\nbindPort = 7000 部署 frpc 客户端并配置\n在需要将内网服务暴露到公网的机器上部署 frpc，并创建如下配置：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[proxies]] name = \"secret_ssh\" type = \"stcp\" # 只有与此处设置的 secretKey 一致的用户才能访问此服务 secretKey = \"abcdefg\" localIP = \"127.0.0.1\" localPort = 22 在访问者机器上部署并配置 frpc\n在想要访问内网服务的机器上也部署 frpc，并创建如下配置：\nserverAddr = \"x.x.x.x\" serverPort = 7000 [[visitors]] name = \"secret_ssh_visitor\" type = \"stcp\" # 要访问的 stcp 代理的名字 serverName = \"secret_ssh\" secretKey = \"abcdefg\" # 绑定本地端口以访问 SSH 服务 bindAddr = \"127.0.0.1\" bindPort = 6000 通过 SSH 访问内网机器\n使用以下命令通过 SSH 访问内网机器，假设用户名为 test：\nssh -o Port=6000 test@127.0.0.1 ","categories":"","description":"通过创建一个只有授权用户能够访问的 SSH 服务代理，实现内网服务的安全暴露。\n","excerpt":"通过创建一个只有授权用户能够访问的 SSH 服务代理，实现内网服务的安全暴露。\n","ref":"/zh-cn/docs/examples/stcp/","tags":"","title":"安全地暴露内网服务"},{"body":"frp provides a new proxy type xtcp for intranet penetration when you need to transfer large amounts of data and don’t want traffic to go through the server.\nSimilar to stcp, using xtcp requires deploying frpc on both ends to establish a direct connection.\nNote that xtcp is not suitable for all types of NAT devices. If penetration fails, you can try using stcp proxy.\nSteps Configure frpc.toml file on the machine that needs to be exposed to the external network\nAdd the following content to the frpc.toml file, ensuring the correct server address and port are set, along with the shared key (secretKey), and the IP address and port of the local service:\nserverAddr = \"x.x.x.x\" serverPort = 7000 # If the default STUN server is unavailable, you can configure a new STUN server # natHoleStunServer = \"xxx\" [[proxies]] name = \"p2p_ssh\" type = \"xtcp\" # Only users with the same secretKey as the server can access this service secretKey = \"abcdefg\" localIP = \"127.0.0.1\" localPort = 22 Deploy frpc on the machine that wants to access the intranet service\nAdd the following content to the frpc.toml file, ensuring the correct server address and port are set, along with the shared key (secretKey) and the name of the P2P proxy to access:\nserverAddr = \"x.x.x.x\" serverPort = 7000 # If the default STUN server is unavailable, you can configure a new STUN server # natHoleStunServer = \"xxx\" [[visitors]] name = \"p2p_ssh_visitor\" type = \"xtcp\" # Name of the P2P proxy to access serverName = \"p2p_ssh\" secretKey = \"abcdefg\" # Bind local port to access SSH service bindAddr = \"127.0.0.1\" bindPort = 6000 # If you need to automatically keep the tunnel open, set it to true # keepTunnelOpen = false Access the intranet machine via SSH\nUse the SSH command to access the intranet machine, assuming the username is test:\nssh -oPort=6000 test@127.0.0.1 ","categories":"","description":"This example demonstrates how to access intranet services through point-to-point (P2P) connections, with traffic not relayed through the server.\n","excerpt":"This example demonstrates how to access intranet services through …","ref":"/en/docs/examples/xtcp/","tags":"","title":"Point-to-Point Intranet Penetration"},{"body":"frp 提供了一种新的代理类型 xtcp，用于在需要传输大量数据且不希望流量经过服务器的情况下实现内网穿透。\n与 stcp 类似，使用 xtcp 需要在两端都部署 frpc 以建立直接连接。\n需要注意的是，xtcp 并不适用于所有类型的 NAT 设备，如果穿透失败，可以尝试使用 stcp 代理。\n步骤 配置需要暴露到外网的机器上的 frpc.toml 文件\n在 frpc.toml 文件中添加以下内容，确保设置了正确的服务器地址和端口以及共享密钥 (secretKey)，以及本地服务的 IP 地址和端口：\nserverAddr = \"x.x.x.x\" serverPort = 7000 # 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器 # natHoleStunServer = \"xxx\" [[proxies]] name = \"p2p_ssh\" type = \"xtcp\" # 只有共享密钥 (secretKey) 与服务器端一致的用户才能访问该服务 secretKey = \"abcdefg\" localIP = \"127.0.0.1\" localPort = 22 在想要访问内网服务的机器上部署 frpc\n在 frpc.toml 文件中添加以下内容，确保设置了正确的服务器地址和端口，共享密钥 (secretKey) 以及要访问的 P2P 代理的名称：\nserverAddr = \"x.x.x.x\" serverPort = 7000 # 如果默认的 STUN 服务器不可用，可以配置一个新的 STUN 服务器 # natHoleStunServer = \"xxx\" [[visitors]] name = \"p2p_ssh_visitor\" type = \"xtcp\" # 要访问的 P2P 代理的名称 serverName = \"p2p_ssh\" secretKey = \"abcdefg\" # 绑定本地端口以访问 SSH 服务 bindAddr = \"127.0.0.1\" bindPort = 6000 # 如果需要自动保持隧道打开，将其设置为 true # keepTunnelOpen = false 通过 SSH 访问内网机器\n使用 SSH 命令访问内网机器，假设用户名为 test：\nssh -oPort=6000 test@127.0.0.1 ","categories":"","description":"这个示例将演示如何通过点对点 (P2P) 连接来访问内网服务，流量不会通过服务器中转。\n","excerpt":"这个示例将演示如何通过点对点 (P2P) 连接来访问内网服务，流量不会通过服务器中转。\n","ref":"/zh-cn/docs/examples/xtcp/","tags":"","title":"点对点内网穿透"},{"body":"","categories":"","description":"Provides rich communication protocols and security features.\n","excerpt":"Provides rich communication protocols and security features.\n","ref":"/en/docs/features/common/network/","tags":"","title":"Communication Security and Optimization"},{"body":" Note: VirtualNet is an Alpha-stage feature that is currently unstable. Its configuration methods and functionality may change at any time in future versions. Please do not use this feature in production environments; it is only recommended for testing and evaluation purposes.\nOverview Virtual Network (VirtualNet) functionality is an Alpha feature introduced in frp v0.62.0, which allows frp to create and manage virtual network connections between clients and visitors through TUN interfaces, enabling complete network connectivity between devices.\nThis example will show how to configure and use the VirtualNet feature. For more detailed information and working principles, please refer to the Virtual Network (VirtualNet) feature documentation.\nEnable VirtualNet First, since VirtualNet is currently an Alpha feature, you need to enable it through feature gates in the configuration:\n# frpc.toml featureGates = { VirtualNet = true } Example Configuration The following example shows how to establish a virtual network connection between two machines:\nServer Configuration (Machine A) Configure virtual network address in frpc.toml\n# frpc.toml (server) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # Configure virtual network interface virtualNet.address = \"100.86.0.1/24\" [[proxies]] name = \"vnet-server\" type = \"stcp\" secretKey = \"your-secret-key\" [proxies.plugin] type = \"virtual_net\" Start frpc\nsudo frpc -c frpc.toml Note: Creating TUN interfaces requires root privileges\nClient Configuration (Machine B) Configure visitor in frpc.toml\n# frpc.toml (client) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # Configure virtual network interface virtualNet.address = \"100.86.0.2/24\" [[visitors]] name = \"vnet-visitor\" type = \"stcp\" serverName = \"vnet-server\" secretKey = \"your-secret-key\" bindPort = -1 [visitors.plugin] type = \"virtual_net\" destinationIP = \"100.86.0.1\" Start frpc\nsudo frpc -c frpc.toml Test Connection After successful configuration, you can access machine A from machine B through the virtual IP address:\n# Execute on machine B ping 100.86.0.1 If the connection is normal, you will see responses from 100.86.0.1.\nLimitations and Requirements Alpha-stage feature: VirtualNet is experimental functionality, configuration and API may change in future versions, not recommended for production use Permission requirements: Creating TUN interfaces requires elevated privileges (root/administrator) Platform support: Currently only supports Linux and macOS Default state: As an Alpha feature, VirtualNet is disabled by default ","categories":"","description":"Use the `virtual_net` plugin to create virtual network connections, enabling IP-layer communication between clients.\n","excerpt":"Use the `virtual_net` plugin to create virtual network connections, …","ref":"/en/docs/examples/virtualnet/","tags":"","title":"Virtual Network (VirtualNet)"},{"body":" 注意：VirtualNet 是一个 Alpha 阶段的特性，目前不稳定，其配置方式和功能可能会在后续版本中随时调整变更。请勿在生产环境中使用此功能，仅建议用于测试和评估目的。\n概述 虚拟网络（VirtualNet）功能是 frp v0.62.0 中引入的 Alpha 特性，它允许 frp 通过 TUN 接口创建和管理客户端与访问者之间的虚拟网络连接，实现设备间的完整网络连通性。\n本示例将展示如何配置和使用 VirtualNet 功能。更多详细信息和工作原理，请参考 虚拟网络 (VirtualNet) 特性文档。\n启用 VirtualNet 首先，由于 VirtualNet 目前是一个 Alpha 特性，您需要在配置中通过特性门控来启用它：\n# frpc.toml featureGates = { VirtualNet = true } 示例配置 以下示例展示如何在两台机器之间建立虚拟网络连接：\n服务端配置 (机器 A) 在 frpc.toml 中配置虚拟网络地址\n# frpc.toml (服务端) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # 配置虚拟网络接口 virtualNet.address = \"100.86.0.1/24\" [[proxies]] name = \"vnet-server\" type = \"stcp\" secretKey = \"your-secret-key\" [proxies.plugin] type = \"virtual_net\" 启动 frpc\nsudo frpc -c frpc.toml 注意：创建 TUN 接口需要 root 权限\n客户端配置 (机器 B) 在 frpc.toml 中配置访问者\n# frpc.toml (客户端) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # 配置虚拟网络接口 virtualNet.address = \"100.86.0.2/24\" [[visitors]] name = \"vnet-visitor\" type = \"stcp\" serverName = \"vnet-server\" secretKey = \"your-secret-key\" bindPort = -1 [visitors.plugin] type = \"virtual_net\" destinationIP = \"100.86.0.1\" 启动 frpc\nsudo frpc -c frpc.toml 测试连接 成功配置后，您可以从机器 B 通过虚拟 IP 地址访问机器 A：\n# 在机器 B 上执行 ping 100.86.0.1 如果连接正常，您将看到来自 100.86.0.1 的响应。\n限制和要求 Alpha 阶段特性：VirtualNet 是实验性功能，配置和 API 可能在未来版本中变化，不建议在生产环境中使用 权限要求：创建 TUN 接口需要提升的权限（root/管理员） 平台支持：目前仅支持 Linux 和 macOS 默认状态：作为 Alpha 特性，VirtualNet 默认是禁用的 ","categories":"","description":"使用 `virtual_net` 插件创建虚拟网络连接，实现客户端之间的 IP 层通信。\n","excerpt":"使用 `virtual_net` 插件创建虚拟网络连接，实现客户端之间的 IP 层通信。\n","ref":"/zh-cn/docs/examples/virtualnet/","tags":"","title":"虚拟网络 (VirtualNet)"},{"body":"","categories":"","description":"提供丰富的通信协议和安全性。\n","excerpt":"提供丰富的通信协议和安全性。\n","ref":"/zh-cn/docs/features/common/network/","tags":"","title":"通信安全及优化"},{"body":"Load Balancing You can add multiple proxies of the same type to the same group to implement load balancing capabilities.\nCurrently supported proxy types include: tcp, http, https, tcpmux.\n# frpc.toml [[proxies]] name = \"test1\" type = \"tcp\" localPort = 8080 remotePort = 80 loadBalancer.group = \"web\" loadBalancer.groupKey = \"123\" [[proxies]] name = \"test2\" type = \"tcp\" localPort = 8081 remotePort = 80 loadBalancer.group = \"web\" loadBalancer.groupKey = \"123\" When users connect to port 80 of the frps server, frps will randomly distribute received user connections to one of the surviving proxies. This ensures that even if one frpc machine fails, other nodes can still provide services.\nFor tcp type proxies, ensure that groupKey is the same for permission verification, and remotePort must also be consistent.\nFor http type proxies, ensure that groupKey, customDomains (custom domain names), subdomain, and locations are the same.\nHealth Check By configuring health check parameters for proxies, you can remove a service from frps when the service to be reverse proxied fails. Combined with load balancing functionality, this can be used to implement high availability architecture and avoid single point of failure.\nTo enable health check functionality, you need to add healthCheck.type = {type} to each proxy’s configuration.\nCurrently supported types are tcp and http.\nFor tcp, as long as a connection can be established, the service is considered normal. For http, an HTTP request will be sent, and the service needs to return a 2xx status code to be considered normal. The following is a tcp example configuration:\n[[proxies]] name = \"test1\" type = \"tcp\" localPort = 22 remotePort = 6000 # Enable health check, type is tcp healthCheck.type = \"tcp\" # Connection timeout is 3 seconds healthCheck.timeoutSeconds = 3 # After 3 consecutive check failures, this proxy will be removed healthCheck.maxFailed = 3 # Perform health check every 10 seconds healthCheck.intervalSeconds = 10 The following is an http example configuration:\n[[proxies]] name = \"web\" type = \"http\" localIP = \"127.0.0.1\" localPort = 80 customDomains = [\"test.yourdomain.com\"] # Enable health check, type is http healthCheck.type = \"http\" # Path for health check HTTP request, backend service needs to return 2xx HTTP status code healthCheck.path = \"/status\" healthCheck.timeoutSeconds = 3 healthCheck.maxFailed = 3 healthCheck.intervalSeconds = 10 ","categories":"","description":"","excerpt":"Load Balancing You can add multiple proxies of the same type to the …","ref":"/en/docs/features/common/load-balancer/","tags":"","title":"Load Balancing and Health Check"},{"body":"负载均衡 你可以将多个相同类型的代理加入到同一个 group 中，以实现负载均衡的能力。\n目前支持的代理类型包括：tcp, http, https, tcpmux。\n# frpc.toml [[proxies]] name = \"test1\" type = \"tcp\" localPort = 8080 remotePort = 80 loadBalancer.group = \"web\" loadBalancer.groupKey = \"123\" [[proxies]] name = \"test2\" type = \"tcp\" localPort = 8081 remotePort = 80 loadBalancer.group = \"web\" loadBalancer.groupKey = \"123\" 当用户连接 frps 服务器的 80 端口时，frps 会将接收到的用户连接随机分发给其中一个存活的代理。这可以确保即使一台 frpc 机器挂掉，仍然有其他节点能够提供服务。\n对于 tcp 类型代理，需要确保 groupKey 相同以进行权限验证，同时 remotePort 也需一致。\n对于 http 类型代理，需要保证 groupKey, customDomains(自定义域名)，subdomain 和 locations 相同。\n健康检查 通过给代理配置健康检查参数，可以在要反向代理的服务出现故障时，将该服务从 frps 中摘除。结合负载均衡的功能，这可用于实现高可用架构，避免服务单点故障。\n要启用健康检查功能，需要在每个代理的配置中添加 healthCheck.type = {type}。\n目前支持的类型有 tcp 和 http。\n对于 tcp，只要能够建立连接，即认为服务正常。 对于 http，会发送一个 HTTP 请求，服务需要返回状态码 2xx 才会被视为正常。 以下是 tcp 示例配置：\n[[proxies]] name = \"test1\" type = \"tcp\" localPort = 22 remotePort = 6000 # 启用健康检查，类型为 tcp healthCheck.type = \"tcp\" # 建立连接超时时间为 3 秒 healthCheck.timeoutSeconds = 3 # 连续 3 次检查失败，此 proxy 会被摘除 healthCheck.maxFailed = 3 # 每隔 10 秒进行一次健康检查 healthCheck.intervalSeconds = 10 以下是 http 示例配置：\n[[proxies]] name = \"web\" type = \"http\" localIP = \"127.0.0.1\" localPort = 80 customDomains = [\"test.yourdomain.com\"] # 启用健康检查，类型为 http healthCheck.type = \"http\" # 健康检查发送 http 请求的 path，后端服务需要返回 2xx 的 http 状态码 healthCheck.path = \"/status\" healthCheck.timeoutSeconds = 3 healthCheck.maxFailed = 3 healthCheck.intervalSeconds = 10 ","categories":"","description":"","excerpt":"负载均衡 你可以将多个相同类型的代理加入到同一个 group 中，以实现负载均衡的能力。\n目前支持的代理类型包括：tcp, http, …","ref":"/zh-cn/docs/features/common/load-balancer/","tags":"","title":"负载均衡与健康检查"},{"body":"HTTP X-Forwarded-For Currently, only http type proxies or proxies with https2http or https2https plugins enabled support this feature.\nYou can get the real user IP through the X-Forwarded-For in HTTP request headers, which is enabled by default.\nProxy Protocol frp supports passing the real IP of requests proxied through frp via the Proxy Protocol protocol.\nAfter the Proxy Protocol feature is enabled, frpc will first send a section of Proxy Protocol protocol content to the local service after establishing a connection with the local service. The local service can obtain the real IP of the accessing user by parsing this content. So not only HTTP services, but any TCP service that supports this protocol can obtain the user’s real IP address.\nUDP proxy types also support Proxy Protocol functionality, which can preserve the real client IP address.\nNote that if you want to enable this feature in proxy configuration, the local service needs to support the Proxy Protocol protocol. Currently, nginx and haproxy both support this protocol well.\nTCP/HTTPS Proxy Example Here’s an example using HTTPS type:\n# frpc.toml [[proxies]] name = \"web\" type = \"https\" localPort = 443 customDomains = [\"test.yourdomain.com\"] # Currently supports v1 and v2 versions of proxy protocol. transport.proxyProtocolVersion = \"v2\" You only need to add one line transport.proxyProtocolVersion = \"v2\" to the proxy configuration to enable this feature.\nLocal HTTPS services can enable Proxy Protocol parsing in nginx configuration and set the result in the X-Real-IP header, so you can get the user’s real IP through X-Real-IP in your web service.\nUDP Proxy Example UDP proxies also support Proxy Protocol functionality:\n# frpc.toml [[proxies]] name = \"dns\" type = \"udp\" localIP = \"127.0.0.1\" localPort = 53 remotePort = 6000 # Enable Proxy Protocol support for UDP proxy transport.proxyProtocolVersion = \"v2\" After enabling, frps and frpc will write source IP information into the Proxy Protocol header. Backend UDP services or logging systems can accurately identify the visitor’s real IP address, which is particularly useful for security auditing and access control.\n","categories":"","description":"","excerpt":"HTTP X-Forwarded-For Currently, only http type proxies or proxies with …","ref":"/en/docs/features/common/realip/","tags":"","title":"Get Real User IP"},{"body":"HTTP X-Forwarded-For 目前只有 http 类型的代理或者启用了 https2http 或 https2https 插件的代理支持这一功能。\n可以通过 HTTP 请求 header 中的 X-Forwarded-For 来获取用户真实 IP，默认启用。\nProxy Protocol frp 支持通过 Proxy Protocol 协议来传递经过 frp 代理的请求的真实 IP。\nProxy Protocol 功能启用后，frpc 在和本地服务建立连接后，会先发送一段 Proxy Protocol 的协议内容给本地服务，本地服务通过解析这一内容可以获得访问用户的真实 IP。所以不仅仅是 HTTP 服务，任何的 TCP 服务，只要支持这一协议，都可以获得用户的真实 IP 地址。\nUDP 代理类型也支持 Proxy Protocol 功能，能够保留真实客户端 IP 地址。\n需要注意的是，在代理配置中如果要启用此功能，需要本地的服务能够支持 Proxy Protocol 这一协议，目前 nginx 和 haproxy 都能够很好的支持。\nTCP/HTTPS 代理示例 这里以 HTTPS 类型为例:\n# frpc.toml [[proxies]] name = \"web\" type = \"https\" localPort = 443 customDomains = [\"test.yourdomain.com\"] # 目前支持 v1 和 v2 两个版本的 proxy protocol 协议。 transport.proxyProtocolVersion = \"v2\" 只需要在代理配置中增加一行 transport.proxyProtocolVersion = \"v2\" 即可开启此功能。\n本地的 HTTPS 服务可以通过在 nginx 的配置中启用 Proxy Protocol 的解析并将结果设置在 X-Real-IP 这个 Header 中就可以在自己的 Web 服务中通过 X-Real-IP 获取到用户的真实 IP。\nUDP 代理示例 UDP 代理也支持 Proxy Protocol 功能：\n# frpc.toml [[proxies]] name = \"dns\" type = \"udp\" localIP = \"127.0.0.1\" localPort = 53 remotePort = 6000 # 启用 UDP 代理的 Proxy Protocol 支持 transport.proxyProtocolVersion = \"v2\" 启用后，frps 和 frpc 会把源 IP 信息写入 Proxy Protocol 头部，后端 UDP 服务或日志系统可以准确识别访问者的真实 IP 地址，这对于安全审计和访问控制特别有用。\n","categories":"","description":"","excerpt":"HTTP X-Forwarded-For 目前只有 http 类型的代理或者启用了 https2http 或 https2https 插件的 …","ref":"/zh-cn/docs/features/common/realip/","tags":"","title":"获取用户真实 IP"},{"body":"Added in v0.56.0\nWe can use Go template’s range syntax combined with the built-in parseNumberRangePair function to implement port range mapping.\nIn the example below, after the application runs, 8 proxies will be created, named test-6000, test-6001 ... test-6007, which will map remote ports to local ports respectively.\n{{- range $_, $v := parseNumberRangePair \"6000-6006,6007\" \"6000-6006,6007\" }} [[proxies]] name = \"tcp-{{ $v.First }}\" type = \"tcp\" localPort = {{ $v.First }} remotePort = {{ $v.Second }} {{- end }} ","categories":"","description":"","excerpt":"Added in v0.56.0\nWe can use Go template’s range syntax combined with …","ref":"/en/docs/features/common/range/","tags":"","title":"Port Range Mapping"},{"body":"Added in v0.56.0\n我们可以利用 Go template 的 range 语法结合内置的 parseNumberRangePair 函数来实现端口范围映射。\n下面的示例，应用运行后会创建 8 个代理，名称为 test-6000, test-6001 ... test-6007，分别将远端的端口映射到本地。\n{{- range $_, $v := parseNumberRangePair \"6000-6006,6007\" \"6000-6006,6007\" }} [[proxies]] name = \"tcp-{{ $v.First }}\" type = \"tcp\" localPort = {{ $v.First }} remotePort = {{ $v.Second }} {{- end }} ","categories":"","description":"","excerpt":"Added in v0.56.0\n我们可以利用 Go template 的 range …","ref":"/zh-cn/docs/features/common/range/","tags":"","title":"端口范围映射"},{"body":"Dynamic Configuration Updates When you need to modify frpc proxy configuration, you can use the frpc reload command to achieve dynamic configuration file loading, usually completing proxy updates within seconds.\nTo enable this feature, you need to enable webServer in frpc to provide API services. The configuration is as follows:\nwebServer.addr = \"127.0.0.1\" webServer.port = 7400 Then execute the following command to reload the configuration:\nfrpc reload -c ./frpc.toml\nAfter waiting for a period of time, the client will create, update, or delete proxies according to the new configuration file. Note that parameters in the non-proxy related common section cannot currently be modified except for start.\nCommand Line Proxy Status View frpc supports viewing proxy status information through the frpc status -c ./frpc.toml command. This feature requires enabling webServer in frpc.\nUsing Proxy to Connect to frps In environments where external networks can only be accessed through proxies, frpc supports establishing connections with frps through HTTP or SOCKS5 proxies.\nYou can use this feature by setting the system environment variable HTTP_PROXY or setting the transport.proxyURL parameter in frpc’s configuration file.\nOnly effective when transport.protocol = \"tcp\".\nserverAddr = \"x.x.x.x\" serverPort = 7000 transport.proxyURL = \"http://user:pwd@192.168.1.128:8080\" Setting transport.proxyURL to socks5://user:pwd@192.168.1.128:8080 can also connect to SOCKS5 proxy.\n","categories":"","description":"","excerpt":"Dynamic Configuration Updates When you need to modify frpc proxy …","ref":"/en/docs/features/common/client/","tags":"","title":"Client"},{"body":"动态配置更新 当你需要修改 frpc 的代理配置时，你可以使用 frpc reload 命令来实现动态加载配置文件，通常在数秒内完成代理的更新。\n要启用此功能，需要在 frpc 中启用 webServer，以提供 API 服务。配置如下：\nwebServer.addr = \"127.0.0.1\" webServer.port = 7400 然后执行以下命令来重载配置：\nfrpc reload -c ./frpc.toml\n等待一段时间后，客户端将根据新的配置文件创建、更新或删除代理。需要注意的是，非代理相关的公共部分的参数除了 start 外目前无法被修改。\n命令行查看代理状态 frpc 支持通过 frpc status -c ./frpc.toml 命令查看代理的状态信息，此功能需要在 frpc 中启用 webServer。\n使用代理连接 frps 在只能通过代理访问外部网络的环境中，frpc 支持通过 HTTP 或 SOCKS5 代理与 frps 建立连接。\n你可以通过设置系统环境变量 HTTP_PROXY 或在 frpc 的配置文件中设置 transport.proxyURL 参数来使用此功能。\n仅在 transport.protocol = \"tcp\" 时生效。\nserverAddr = \"x.x.x.x\" serverPort = 7000 transport.proxyURL = \"http://user:pwd@192.168.1.128:8080\" 将 transport.proxyURL 设置为 socks5://user:pwd@192.168.1.128:8080 也可以连接到 SOCKS5 代理。\n","categories":"","description":"","excerpt":"动态配置更新 当你需要修改 frpc 的代理配置时，你可以使用 frpc reload 命令来实现动态加载配置文件，通常在数秒内完成代理的更 …","ref":"/zh-cn/docs/features/common/client/","tags":"","title":"客户端"},{"body":"Port Whitelist To prevent port abuse, you can manually specify which ports are allowed to be used. In the server configuration, specify through allowPorts:\n# frps.ini allowPorts = [ { start = 2000, end = 3000 }, { single = 3001 }, { single = 3003 }, { start = 4000, end = 50000 } ] allowPorts can configure a specific port or all ports within a range to be allowed.\nPort Reuse Currently, vhostHTTPPort and vhostHTTPSPort in frps support being configured as the same port as bindPort. frps will analyze the connection protocol and then handle it differently.\nFor example, in some restrictive network environments, you can set both bindPort and vhostHTTPSPort to 443.\nNote that if you want to configure vhostHTTPSPort and bindPort as the same port, you need to first set transport.tls.disableCustomTLSFirstByte to false.\nRate Limiting Proxy Rate Limiting Currently supports setting proxy-level rate limiting in the client’s proxy configuration, limiting the bandwidth that a single proxy can occupy.\n# frpc.toml [[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 transport.bandwidthLimit = \"1MB\" Add the transport.bandwidthLimit field to the proxy configuration to enable this feature. Currently only supports MB and KB units.\nRate limiting is implemented on the client side by default. If you want to enable server-side rate limiting, you need to additionally configure transport.bandwidthLimitMode = \"server\".\n","categories":"","description":"","excerpt":"Port Whitelist To prevent port abuse, you can manually specify which …","ref":"/en/docs/features/common/server-manage/","tags":"","title":"Server Management"},{"body":"端口白名单 为了防止端口被滥用，可以手动指定允许哪些端口被使用，在服务端配置中通过 allowPorts 来指定：\n# frps.ini allowPorts = [ { start = 2000, end = 3000 }, { single = 3001 }, { single = 3003 }, { start = 4000, end = 50000 } ] allowPorts 可以配置允许使用的某个指定端口或者是一个范围内的所有端口。\n端口复用 目前 frps 中的 vhostHTTPPort 和 vhostHTTPSPort 支持配置成和 bindPort 为同一个端口，frps 会对连接的协议进行分析，之后进行不同的处理。\n例如在某些限制较严格的网络环境中，可以将 bindPort 和 vhostHTTPSPort 都设置为 443。\n需要注意的是，如果你想将 vhostHTTPSPort 和 bindPort 配置为相同的端口，需要首先将 transport.tls.disableCustomTLSFirstByte 设置为false。\n限速 代理限速 目前支持在客户端的代理配置中设置代理级别的限速，限制单个 proxy 可以占用的带宽。\n# frpc.toml [[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 transport.bandwidthLimit = \"1MB\" 在代理配置中增加 transport.bandwidthLimit 字段启用此功能，目前仅支持 MB 和 KB 单位。\n限速能力默认在客户端实现，如果希望启用服务端限速，需要额外配置 transport.bandwidthLimitMode = \"server\"。\n","categories":"","description":"","excerpt":"端口白名单 为了防止端口被滥用，可以手动指定允许哪些端口被使用，在服务端配置中通过 allowPorts 来指定：\n# frps.ini …","ref":"/zh-cn/docs/features/common/server-manage/","tags":"","title":"服务端管理"},{"body":"By default, frpc will only forward requests to local TCP or UDP ports, i.e., the local service address specified by localIP and localPort.\nBy enabling client plugin functionality, you can build in some simple local services when only starting frpc, thereby achieving functionality that would normally require starting additional services.\nIn each proxy’s configuration, you can configure the plugin to use and related parameters through plugin. After enabling client plugins, you no longer need to configure localIP and localPort.\nClient plugins can be used for various types of proxies, provided the plugin itself supports the protocols. For example, the static file access plugin can be exposed through TCP or HTTP proxies.\nHere’s an example using the http_proxy plugin:\n[[proxies]] name = \"http_proxy\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"http_proxy\" httpUser = \"abc\" httpPassword = \"abc\" httpUser and httpPassword are optional configuration parameters for the http_proxy plugin.\nFor other plugins and related configurations, please refer to the content in Reference.\n","categories":"","description":"","excerpt":"By default, frpc will only forward requests to local TCP or UDP ports, …","ref":"/en/docs/features/common/client-plugin/","tags":"","title":"Client Plugin"},{"body":"默认情况下，frpc 仅会将请求转发到本地 TCP 或 UDP 端口，即通过 localIP 和 localPort 指定的本地服务地址。\n通过启用客户端插件功能，可以在仅启动 frpc 的情况下内置一些简单的本地服务，从而实现通常需要额外启动其他服务才能实现的功能。\n在每个代理的配置中，你可以通过 plugin 来配置要使用的插件和相关参数。启用客户端插件后，无需再配置 localIP 和 localPort。\n客户端插件可用于各种类型的代理，前提是插件本身支持的协议。例如，静态文件访问插件可以通过 TCP 或 HTTP 代理进行暴露。\n以下是使用 http_proxy 插件的示例：\n[[proxies]] name = \"http_proxy\" type = \"tcp\" remotePort = 6000 [proxies.plugin] type = \"http_proxy\" httpUser = \"abc\" httpPassword = \"abc\" httpUser 和 httpPassword 即为 http_proxy 插件可选的配置参数。\n其他插件和相关配置请参考 Reference 中的内容。\n","categories":"","description":"","excerpt":"默认情况下，frpc 仅会将请求转发到本地 TCP 或 UDP 端口，即通过 localIP 和 localPort 指定的本地服务地址。\n …","ref":"/zh-cn/docs/features/common/client-plugin/","tags":"","title":"客户端插件"},{"body":"The purpose of frp server plugins is to extend the capabilities of the frp server without intruding on its own code.\nfrp server plugins run as separate processes and listen on a port, providing RPC interfaces externally to respond to frps requests.\nBefore executing certain operations, frps will send RPC requests to server plugins according to configuration, and execute corresponding operations based on the plugin’s response.\nRPC Requests After receiving operation requests, server plugins can give three types of responses:\nReject operation, need to return the reason for rejecting the operation. Allow operation, no need to modify operation content. Allow operation, modify the operation request and return the modified content. Interface The interface path can be configured separately for each plugin in frps configuration. Here we use /handler as an example.\nRequest\nPOST /handler?version=0.1.0\u0026op=Login { \"content\": { ... // Specific operation information } } Request Header X-Frp-Reqid: For tracking requests Response\nAny non-200 return is considered a request exception.\nReject operation execution\n{ \"reject\": true, \"reject_reason\": \"invalid user\" } Allow and content doesn’t need to change\n{ \"reject\": false, \"unchange\": true } Allow and need to replace operation content\n{ \"unchange\": false, \"content\": { ... // Replaced operation information, format must be consistent with request } } Operation Types Currently, the plugin supports managing operation types: Login, NewProxy, CloseProxy, Ping, NewWorkConn, and NewUserConn.\nLogin User login operation information\n{ \"content\": { \"version\": \u003cstring\u003e, \"hostname\": \u003cstring\u003e, \"os\": \u003cstring\u003e, \"arch\": \u003cstring\u003e, \"user\": \u003cstring\u003e, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e, \"run_id\": \u003cstring\u003e, \"pool_count\": \u003cint\u003e, \"metas\": map\u003cstring\u003estring, \"client_address\": \u003cstring\u003e } } NewProxy Information related to creating proxy\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"use_encryption\": \u003cbool\u003e, \"use_compression\": \u003cbool\u003e, \"bandwidth_limit\": \u003cstring\u003e, \"bandwidth_limit_mode\": \u003cstring\u003e, \"group\": \u003cstring\u003e, \"group_key\": \u003cstring\u003e, // tcp and udp only \"remote_port\": \u003cint\u003e, // http and https only \"custom_domains\": []\u003cstring\u003e, \"subdomain\": \u003cstring\u003e, \"locations\": []\u003cstring\u003e, \"http_user\": \u003cstring\u003e, \"http_pwd\": \u003cstring\u003e, \"host_header_rewrite\": \u003cstring\u003e, \"headers\": map\u003cstring\u003estring, // stcp only \"sk\": \u003cstring\u003e, // tcpmux only \"multiplexer\": \u003cstring\u003e \"metas\": map\u003cstring\u003estring } } CloseProxy Proxy closed. (For notification only)\nNote: When a single frpc registers a large number of proxies, use this interface carefully, as it may affect service availability due to connection limits.\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e } } Ping Heartbeat related information\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewWorkConn Create work connection\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"run_id\": \u003cstring\u003e \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewUserConn Create user connection (supports tcp, stcp, https, and tcpmux protocols).\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"remote_addr\": \u003cstring\u003e } } Plugin Configuration in frps bindPort = 7000 [[httpPlugins]] name = \"user-manager\" addr = \"127.0.0.1:9000\" path = \"/handler\" ops = [\"Login\"] [[httpPlugins]] name = \"port-manager\" addr = \"127.0.0.1:9001\" path = \"/handler\" ops = [\"NewProxy\"] addr: Network address the plugin listens on, supports HTTP and HTTPS, defaults to HTTP. path: Request path the plugin listens on. ops: List of operations the plugin needs to handle, multiple ops separated by commas. tls_verify: If using HTTPS protocol, supports ignoring TLS identity verification. Metadata To reduce code modifications in frps while improving the extensibility of management plugins, the concept of custom metadata is introduced in frpc configuration files. Metadata will be sent to plugins when making RPC requests.\nThere are two types of metadata entries: global entries and entries under each proxy configuration. Global metadata will be attached to Login requests when the client logs in, and attached to user.metas in other RPC requests.\nMetadata entries under each proxy configuration will only be passed through metas in NewProxy operations.\n# frpc.toml serverAddr = \"127.0.0.1\" serverPort = 7000 user = \"fake\" metadatas.token = \"fake\" metadatas.version = \"1.0.0\" [[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 metadatas.id = \"123\" ","categories":"","description":"","excerpt":"The purpose of frp server plugins is to extend the capabilities of the …","ref":"/en/docs/features/common/server-plugin/","tags":"","title":"Server Plugin"},{"body":"frp 服务端插件的作用是在不侵入自身代码的前提下，扩展 frp 服务端的能力。\nfrp 服务端插件会以单独进程的形式运行，并且监听在一个端口上，对外提供 RPC 接口，响应 frps 的请求。\nfrps 在执行某些操作前，会根据配置向服务端插件发送 RPC 请求，根据插件的响应来执行相应的操作。\nRPC 请求 服务端插件接收到操作请求后，可以给出三种回应。\n拒绝操作，需要返回拒绝操作的原因。 允许操作，不需要修改操作内容。 允许操作，对操作请求进行修改后，返回修改后的内容。 接口 接口路径可以在 frps 配置中为每个插件单独配置，这里以 /handler 为例。\nRequest\nPOST /handler?version=0.1.0\u0026op=Login { \"content\": { ... // 具体的操作信息 } } 请求 Header X-Frp-Reqid: 用于追踪请求 Response\n非 200 的返回都认为是请求异常。\n拒绝执行操作\n{ \"reject\": true, \"reject_reason\": \"invalid user\" } 允许且内容不需要变动\n{ \"reject\": false, \"unchange\": true } 允许且需要替换操作内容\n{ \"unchange\": false, \"content\": { ... // 替换后的操作信息，格式必须和请求时的一致 } } 操作类型 目前插件支持管理的操作类型有 Login、NewProxy、CloseProxy、Ping、NewWorkConn 和 NewUserConn。\nLogin 用户登录操作信息\n{ \"content\": { \"version\": \u003cstring\u003e, \"hostname\": \u003cstring\u003e, \"os\": \u003cstring\u003e, \"arch\": \u003cstring\u003e, \"user\": \u003cstring\u003e, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e, \"run_id\": \u003cstring\u003e, \"pool_count\": \u003cint\u003e, \"metas\": map\u003cstring\u003estring, \"client_address\": \u003cstring\u003e } } NewProxy 创建代理的相关信息\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"use_encryption\": \u003cbool\u003e, \"use_compression\": \u003cbool\u003e, \"bandwidth_limit\": \u003cstring\u003e, \"bandwidth_limit_mode\": \u003cstring\u003e, \"group\": \u003cstring\u003e, \"group_key\": \u003cstring\u003e, // tcp and udp only \"remote_port\": \u003cint\u003e, // http and https only \"custom_domains\": []\u003cstring\u003e, \"subdomain\": \u003cstring\u003e, \"locations\": []\u003cstring\u003e, \"http_user\": \u003cstring\u003e, \"http_pwd\": \u003cstring\u003e, \"host_header_rewrite\": \u003cstring\u003e, \"headers\": map\u003cstring\u003estring, // stcp only \"sk\": \u003cstring\u003e, // tcpmux only \"multiplexer\": \u003cstring\u003e \"metas\": map\u003cstring\u003estring } } CloseProxy 代理关闭。(仅用于通知)\n注意: 当单个 frpc 会注册大量 proxy 时，慎重使用此接口，可能会由于连接数超限而影响服务的可用性。\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e } } Ping 心跳相关信息\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewWorkConn 创建工作连接\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"run_id\": \u003cstring\u003e \"timestamp\": \u003cint64\u003e, \"privilege_key\": \u003cstring\u003e } } NewUserConn 创建用户连接 (支持 tcp、stcp、https 和 tcpmux 协议)。\n{ \"content\": { \"user\": { \"user\": \u003cstring\u003e, \"metas\": map\u003cstring\u003estring \"run_id\": \u003cstring\u003e }, \"proxy_name\": \u003cstring\u003e, \"proxy_type\": \u003cstring\u003e, \"remote_addr\": \u003cstring\u003e } } frps 中插件配置 bindPort = 7000 [[httpPlugins]] name = \"user-manager\" addr = \"127.0.0.1:9000\" path = \"/handler\" ops = [\"Login\"] [[httpPlugins]] name = \"port-manager\" addr = \"127.0.0.1:9001\" path = \"/handler\" ops = [\"NewProxy\"] addr: 插件监听的网络地址，支持 HTTP 和 HTTPS，默认为 HTTP。 path: 插件监听的请求路径。 ops: 插件需要处理的操作列表，多个 op 以英文逗号分隔。 tls_verify: 如果是 HTTPS 协议，支持忽略 TLS 身份验证。 元数据 为了减少 frps 的代码修改，同时提高管理插件的扩展能力，在 frpc 的配置文件中引入自定义元数据的概念。元数据会在调用 RPC 请求时发送给插件。\n有两种类型的元数据条目，全局条目和每个代理配置下的条目。全局元数据将在客户端登录时附加在 Login 请求中，并在其他 RPC 请求中附加在 user.metas 中。\n每个代理配置下的元数据条目仅会在 NewProxy 操作中通过 metas 传递。\n# frpc.toml serverAddr = \"127.0.0.1\" serverPort = 7000 user = \"fake\" metadatas.token = \"fake\" metadatas.version = \"1.0.0\" [[proxies]] name = \"ssh\" type = \"tcp\" localPort = 22 remotePort = 6000 metadatas.id = \"123\" ","categories":"","description":"","excerpt":"frp 服务端插件的作用是在不侵入自身代码的前提下，扩展 frp 服务端的能力。\nfrp 服务端插件会以单独进程的形式运行，并且监听在一个端 …","ref":"/zh-cn/docs/features/common/server-plugin/","tags":"","title":"服务端插件"},{"body":"Added in v0.53.0\nConcept SSH supports reverse proxy capability rfc.\nfrp supports listening on an SSH port on the frps side, completing TCP protocol proxy through the SSH -R protocol. In this mode, there is no need to depend on frpc.\nSSH reverse tunnel proxy and proxying SSH ports through frp are two different concepts. SSH reverse tunnel proxy is essentially using ssh client to connect to frps to complete basic reverse proxy when you don’t want to use frpc.\nParameters # frps.toml sshTunnelGateway.bindPort = 0 sshTunnelGateway.privateKeyFile = \"\" sshTunnelGateway.autoGenPrivateKeyPath = \"\" sshTunnelGateway.authorizedKeysFile = \"\" Field Type Description Required bindPort int SSH server port that frps listens on. YES privateKeyFile string Default is empty. Private key file used by ssh server. If empty, frps will read the private key file under autoGenPrivateKeyPath. Can reuse local /home/user/.ssh/id_rsa file or custom path. No autoGenPrivateKeyPath string Default is ./.autogen_ssh_key. If file doesn’t exist or is empty, frps will automatically generate RSA private key file content and save it to this file. No authorizedKeysFile string Default is empty. Empty means no authentication for ssh clients. Non-empty can implement ssh passwordless login authentication, can reuse local /home/user/.ssh/authorized_keys file or custom path. No Basic Usage Server frps Minimal configuration\nsshTunnelGateway.bindPort = 2200 Put the above configuration in frps.toml, run ./frps -c frps.toml, it will listen on port 2200 and accept SSH reverse proxy requests.\nNotes:\nUsing minimal configuration will automatically create a .autogen_ssh_key private key file in the current running directory. The frps ssh server will use this private key file to encrypt and decrypt data. You can also reuse existing local private key files, such as /home/user/.ssh/id_rsa. frps running in minimal configuration mode does not authenticate SSH connections. It is strongly recommended to configure token for frps and specify token in SSH command line. Client ssh Command format is\nssh -R :80:{local_ip:port} v0@{frps address} -p {frps ssh listen port} {tcp|http|https|stcp|tcpmux} --remote_port {real remote port} --proxy_name {proxy_name} --token {frp token} --proxy_name is optional, a random one will be generated if empty. The username for logging into frps is unified as v0, which has no meaning currently, i.e. v0@{frps address}. The port that the server proxy listens on is determined by --remote_port. Complete command parameters supported by {tcp|http|https|stcp|tcpmux} can be obtained through –help. For example: ssh -R :80::8080 v0@127.0.0.1 -p 2200 http --help token is optional, strongly recommended to configure token on frps for security. TCP Proxy ssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 tcp --proxy_name \"test-tcp\" --remote_port 9090 Start a port 9090 on frps to proxy local port 8080 service.\nfrp (via SSH) (Ctrl+C to quit) User: ProxyName: test-tcp Type: tcp RemoteAddress: :9090 Equivalent to:\nfrpc tcp --proxy_name \"test-tcp\" --local_ip 127.0.0.1 --local_port 8080 --remote_port 9090 More parameters can be obtained by executing –help.\nHTTP Proxy ssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 http --proxy_name \"test-http\" --custom_domain test-http.frps.com Equivalent to\nfrpc http --proxy_name \"test-http\" --custom_domain test-http.frps.com You can access the http service with the following command:\ncurl 'http://test-http.frps.com'\nMore parameters can be obtained by executing --help.\nHTTPS/STCP/TCPMUX Proxy Get usage through the following command:\nssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 {https|stcp|tcpmux} --help\nAdvanced Usage Reuse Local id_rsa File # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.privateKeyFile = \"/home/user/.ssh/id_rsa\" The SSH protocol handshake stage requires exchanging public keys to encrypt data, so the SSH server on the frps side needs to specify a private key file, which can reuse existing local ones; if empty, frps will automatically create an RSA private key file.\nSpecify Auto-generated Private Key File Address # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.autoGenPrivateKeyPath = \"/var/frp/ssh-private-key-file\" frps automatically creates private key file and specifies path for storage.\nNote: frps changing private key file will cause SSH client login failure. If you need successful login, you can delete old records in /home/user/.ssh/known_hosts file.\nUse Existing authorized_keys File for SSH Passwordless Login Authentication # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.authorizedKeysFile = \"/home/user/.ssh/authorized_keys\" authorizedKeysFile is the file used for SSH passwordless login, storing user public key information, one per line.\nIf authorizedKeysFile is empty, frps does not authenticate SSH clients. frps does not support SSH username+password authentication mode.\nYou can reuse existing local authorized_keys file to authenticate clients.\nNote: authorizedKeysFile is user authentication during SSH login stage, token is existing frps authentication, the two are not related. SSH authentication comes first, frps token authentication comes later. It is strongly recommended to enable at least one. If authorizedKeysFile is empty, it is strongly recommended to enable token authentication on frps side, otherwise there are security risks.\nUse Custom authorized_keys File for SSH Passwordless Login Authentication # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.authorizedKeysFile = \"/var/frps/custom_authorized_keys_file\" Custom authorized_keys file path.\nChanges to authorizedKeysFile file may cause SSH login authentication failure, you may need to re-add public key information to authorizedKeysFile.\n","categories":"","description":"","excerpt":"Added in v0.53.0\nConcept SSH supports reverse proxy capability rfc. …","ref":"/en/docs/features/common/ssh/","tags":"","title":"SSH Tunnel Gateway"},{"body":"Added in v0.53.0\n概念 SSH 支持反向代理能力 rfc。\nfrp 支持在 frps 端监听一个 ssh 端口，通过走 ssh -R 协议来完成 TCP 协议代理，该模式下不需要依赖 frpc。\nSSH 反向隧道代理和通过 frp 代理 SSH 端口是不同的 2 个概念。SSH 反向隧道代理本质上是在你不想使用 frpc 的时候，通过 ssh client 连接 frps 来完成基本的反向代理。\n参数 # frps.toml sshTunnelGateway.bindPort = 0 sshTunnelGateway.privateKeyFile = \"\" sshTunnelGateway.autoGenPrivateKeyPath = \"\" sshTunnelGateway.authorizedKeysFile = \"\" Field Type Description Required bindPort int frps 监听的 ssh server 端口。 YES privateKeyFile string 默认为空。ssh server 使用的私钥文件，为空frps会读取 autoGenPrivateKeyPath 路径下的私钥文件。可复用本地 /home/user/.ssh/id_rsa 文件或自定义路径。 No autoGenPrivateKeyPath string 默认为 ./.autogen_ssh_key。文件不存在或内容为空，frps会自动生成 RSA 私钥文件内容存入该文件。 No authorizedKeysFile string 默认为空。空不对ssh客户端进行鉴权认证。不空可实现ssh免密登录认证，可复用本地 /home/user/.ssh/authorized_keys 文件或自定义路径。 No 基本使用 服务端 frps 最简配置\nsshTunnelGateway.bindPort = 2200 将上述配置放入 frps.toml, 运行 ./frps -c frps.toml，此时会在 2200 的端口监听，接受 ssh 反向代理的请求。\n注意：\n使用最简配置，会在当前运行目录自动创建一个 .autogen_ssh_key 的私钥文件，frps 的 ssh server 会使用到该私钥文件，用来加解密数据。也可以复用本地已有的私钥文件，如 /home/user/.ssh/id_rsa。 最简配置模式下运行的frps，通过 ssh 连接 frps 是不鉴权的，强烈建议 frps 配置 token，在 ssh 命令行指定 token。 客户端 ssh 命令格式为\nssh -R :80:{local_ip:port} v0@{frps address} -p {frps ssh listen port} {tcp|http|https|stcp|tcpmux} --remote_port {real remote port} --proxy_name {proxy_name} --token {frp token} --proxy_name 非必填，为空会随机生成一个。 登录 frps 的用户名统一为 v0，目前没有任何含义，即 v0@{frps address}。 server 端的 proxy 监听的端口由 --remote_port 决定。 {tcp|http|https|stcp|tcpmux} 支持的完整命令参数可通过 –help 获取。 如： ssh -R :80::8080 v0@127.0.0.1 -p 2200 http --help token 非必填，为了安全强烈建议在frps配置上token。 TCP 代理 ssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 tcp --proxy_name \"test-tcp\" --remote_port 9090 在 frps 启动一个 9090 的端口代理本地的 8080 服务。\nfrp (via SSH) (Ctrl+C to quit) User: ProxyName: test-tcp Type: tcp RemoteAddress: :9090 等同于：\nfrpc tcp --proxy_name \"test-tcp\" --local_ip 127.0.0.1 --local_port 8080 --remote_port 9090 更多参数可执行 –help 获取。\nHTTP 代理 ssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 http --proxy_name \"test-http\" --custom_domain test-http.frps.com 等同于\nfrpc http --proxy_name \"test-http\" --custom_domain test-http.frps.com 可以通过以下命令访问 http 服务：\ncurl 'http://test-http.frps.com'\n更多参数可执行 --help 获取。\nHTTPS/STCP/TCPMUX 代理 通过如下命令获取使用方式：\nssh -R :80:127.0.0.1:8080 v0@{frp address} -p 2200 {https|stcp|tcpmux} --help\n高级使用 复用本机的 id_rsa 文件 # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.privateKeyFile = \"/home/user/.ssh/id_rsa\" ssh 协议握手阶段需要交换公钥用来加密数据，所以 frps 端的 ssh server 需要指定一个私钥文件，可以复用本机已存在的；如果为空，frps会自动创建一个 rsa 私钥文件。\n指定自动生成私钥文件地址 # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.autoGenPrivateKeyPath = \"/var/frp/ssh-private-key-file\" frps自动创建私钥文件并指定路径存储。\n注意：frps 更换私钥文件，会导致 ssh 客户端登录失败，如果需要成功登录，可以删除 /home/user/.ssh/known_hosts 文件中的旧的记录。\n使用本机已存在的 authorized_keys 文件，实现 ssh 免密登录鉴权 # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.authorizedKeysFile = \"/home/user/.ssh/authorized_keys\" authorizedKeysFile 是 ssh 免密登录使用的文件，存放用户公钥信息，一行一个。\nauthorizedKeysFile 为空， frps 不对 ssh 客户端进行任何认证。frps 不支持 ssh 用户名+密码模式认证。\n可复用本机已有的 authorized_keys 文件对客户端进行认证。\n注意：authorizedKeysFile 是 ssh 登录阶段的用户认证，token 是 frps 已有的认证，2 者没有关联，ssh 认证在前，frps 认证 token 在后，强烈建议至少开启1个，如果 authorizedKeysFile 为空，强烈建议 frps 端开启 token 认证，否则有安全风险。\n使用自定义的 authorized_keys 文件，实现 ssh 免密登录鉴权 # frps.toml sshTunnelGateway.bindPort = 2200 sshTunnelGateway.authorizedKeysFile = \"/var/frps/custom_authorized_keys_file\" 自定义 authorized_keys 文件路径。\nauthorizedKeysFile 文件变动可能会导致 ssh 登录认证失败，可能需要重新将公钥信息放入 authorizedKeysFile。\n","categories":"","description":"","excerpt":"Added in v0.53.0\n概念 SSH 支持反向代理能力 rfc。\nfrp 支持在 frps 端监听一个 ssh 端口， …","ref":"/zh-cn/docs/features/common/ssh/","tags":"","title":"SSH Tunnel Gateway"},{"body":"Alpha feature, added in v0.62.0\nNote: VirtualNet is an Alpha stage feature that is currently unstable. Its configuration methods and functionality may change at any time in future versions. Please do not use this feature in production environments; it is only recommended for testing and evaluation purposes.\nOverview The Virtual Network (VirtualNet) feature allows frp to create and manage virtual network connections between clients through TUN interfaces. This feature extends frp’s capabilities beyond traditional port forwarding to achieve complete network layer communication.\nWith VirtualNet functionality, you can:\nEstablish IP-level network connections between different clients without needing to configure port forwarding for each service individually Enable applications to access remote services directly via IP without being aware of frp’s existence Create VPN-like connections managed by frp Usage Requirements Using VirtualNet functionality requires meeting the following conditions:\nPermission Requirements: Creating TUN interfaces requires root/administrator privileges Platform Support: Currently only supports Linux and macOS platforms Feature Gates: Must be explicitly enabled by configuring featureGates = { VirtualNet = true } Address Allocation: Each endpoint must be configured with a unique IP address/CIDR Configuration Method Enable VirtualNet Since VirtualNet is an Alpha feature, it needs to be explicitly enabled in the configuration:\n# frpc.toml featureGates = { VirtualNet = true } Server Configuration First, configure the virtual network address for frpc:\n# frpc.toml (server side) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # Configure virtual network interface virtualNet.address = \"100.86.0.1/24\" Then, configure the virtual_net plugin for the proxy:\n# frpc.toml (server side) [[proxies]] name = \"vnet-server\" type = \"stcp\" secretKey = \"your-secret-key\" [proxies.plugin] type = \"virtual_net\" Client Configuration The client needs to configure a visitor plugin to connect to the virtual network:\n# frpc.toml (client side) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # Configure virtual network interface virtualNet.address = \"100.86.0.2/24\" [[visitors]] name = \"vnet-visitor\" type = \"stcp\" serverName = \"vnet-server\" secretKey = \"your-secret-key\" bindPort = -1 [visitors.plugin] type = \"virtual_net\" destinationIP = \"100.86.0.1\" # Target virtual IP address Working Principle VirtualNet functionality is implemented based on the following technologies:\nTUN Virtual Interface: Creates a TUN virtual network interface on each frp client Route Control: Manages routing tables between clients through the VNet controller Packet Forwarding: Encapsulates and forwards IP packets within frp tunnels The workflow is as follows:\nfrp creates TUN interface and assigns IP addresses Server registers connection to VNet controller using virtual_net plugin Client uses virtual_net visitor plugin to route traffic for target IP to corresponding connection Data packets are transmitted in the virtual network managed by frp, achieving IP layer connectivity between different machines ","categories":"","description":"","excerpt":"Alpha feature, added in v0.62.0\nNote: VirtualNet is an Alpha stage …","ref":"/en/docs/features/common/virtualnet/","tags":"","title":"Virtual Network (VirtualNet)"},{"body":"Alpha feature, added in v0.62.0\n注意：VirtualNet 是一个 Alpha 阶段的特性，目前不稳定，其配置方式和功能可能会在后续版本中随时调整变更。请勿在生产环境中使用此功能，仅建议用于测试和评估目的。\n概述 虚拟网络（VirtualNet）功能允许 frp 通过 TUN 接口创建和管理客户端之间的虚拟网络连接。这一功能将 frp 的能力扩展到了传统端口转发之外，实现了完整的网络层通信。\n通过 VirtualNet 功能，你可以：\n在不同客户端之间建立 IP 层级的网络连接，不需要为每个服务单独配置端口转发 使应用程序无需感知 frp 的存在，直接通过 IP 访问远程服务 建立类似 VPN 的连接，但由 frp 负责管理 使用要求 使用 VirtualNet 功能需要满足以下条件：\n权限要求：创建 TUN 接口需要 root/管理员权限 平台支持：目前仅支持 Linux 和 macOS 平台 特性门控：需要通过配置 featureGates = { VirtualNet = true } 显式启用 地址分配：每个端点必须配置唯一的 IP 地址/CIDR 配置方法 启用 VirtualNet 由于 VirtualNet 是 Alpha 特性，需要在配置中显式启用：\n# frpc.toml featureGates = { VirtualNet = true } 服务端配置 首先，为 frpc 配置虚拟网络地址：\n# frpc.toml (服务端) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # 配置虚拟网络接口 virtualNet.address = \"100.86.0.1/24\" 然后，为代理配置 virtual_net 插件：\n# frpc.toml (服务端) [[proxies]] name = \"vnet-server\" type = \"stcp\" secretKey = \"your-secret-key\" [proxies.plugin] type = \"virtual_net\" 客户端配置 客户端需要配置访问者插件以连接到虚拟网络：\n# frpc.toml (客户端) serverAddr = \"x.x.x.x\" serverPort = 7000 featureGates = { VirtualNet = true } # 配置虚拟网络接口 virtualNet.address = \"100.86.0.2/24\" [[visitors]] name = \"vnet-visitor\" type = \"stcp\" serverName = \"vnet-server\" secretKey = \"your-secret-key\" bindPort = -1 [visitors.plugin] type = \"virtual_net\" destinationIP = \"100.86.0.1\" # 目标虚拟 IP 地址 工作原理 VirtualNet 功能基于以下技术实现：\nTUN 虚拟接口：在每个 frp 客户端创建一个 TUN 虚拟网络接口 路由控制：通过 VNet 控制器管理客户端间的路由表 数据包转发：在 frp 隧道内部封装和转发 IP 数据包 工作流程如下：\nfrp 创建 TUN 接口并分配 IP 地址 服务端使用 virtual_net 插件注册连接到 VNet 控制器 客户端使用 virtual_net 访问者插件将目标 IP 的流量路由到对应连接 数据包在 frp 管理的虚拟网络中传输，实现不同机器之间的 IP 层连通性 ","categories":"","description":"","excerpt":"Alpha feature, added in v0.62.0\n注意：VirtualNet 是一个 Alpha 阶段的特性，目前不稳定，其配 …","ref":"/zh-cn/docs/features/common/virtualnet/","tags":"","title":"虚拟网络 (VirtualNet)"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/index.json","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh-cn/index.json","tags":"","title":""},{"body":" Simple and Efficient Intranet Penetration Tool Get Started GITHUB frp supports multiple proxy types and P2P communication, providing rich solutions for different scenarios.\nSimple \u0026 Easy frp adopts a C/S architecture, deploying the server on machines with public IP addresses and clients on machines within intranets or behind firewalls, providing reverse proxy to services in the intranet.\nPowerful Supports multiple protocols including TCP, UDP, HTTP, HTTPS, and provides numerous capabilities such as encryption, compression, authentication, proxy rate limiting, load balancing, and more.\nVersatile Supports multiple proxy types and P2P communication. Additionally, P2P communication can be achieved through xtcp, providing rich solutions for different scenarios.\nSponsors Thank you to our sponsors for supporting the frp project\nGold Sponsors Recall.ai View All Sponsors Become a Sponsor Download Download the latest version from Github Release page.\nContributions welcome! Submit Issues and Pull Requests on Github.\nRead more\nFollow the Author Follow @fatedier on X for the latest updates.\nRead more\n","categories":"","description":"","excerpt":" Simple and Efficient Intranet Penetration Tool Get Started GITHUB frp …","ref":"/en/","tags":"","title":"frp"},{"body":" 简单、高效的内网穿透工具 起步 GITHUB frp 支持多种代理类型以及 P2P 通信，为不同场景下的需求提供丰富的解决方案。\n简单易用 frp 采用 C/S 模式，将服务端部署在具有公网 IP 的机器上，客户端部署在内网或防火墙内的机器上，通过访问暴露在服务器上的端口，反向代理到处于内网的服务。\n功能强大 支持 TCP, UDP, HTTP, HTTPS 等多种协议，提供了加密、压缩，身份认证，代理限速，负载均衡等众多能力。\n灵活配置 支持多种代理类型以及 P2P 通信，还可以通过 xtcp 实现点对点通信，为不同场景提供丰富的解决方案。\n赞助商 感谢我们的赞助商对 frp 项目的支持\nGold Sponsors Recall.ai 查看所有赞助商 成为赞助商 下载 从 Github Release 页面下载最新版本。\n欢迎参与贡献! 在 Github 上提交 Issue 和 Pull Request。\n更多\n关注作者 在 X 上关注作者 @fatedier 获取最新动态。\n更多\n","categories":"","description":"","excerpt":" 简单、高效的内网穿透工具 起步 GITHUB frp 支持多种代理类型以及 P2P 通信，为不同场景下的需求提供丰富的解决方案。 …","ref":"/zh-cn/","tags":"","title":"frp"},{"body":"View on Github Release page\n","categories":"","description":"","excerpt":"View on Github Release page\n","ref":"/en/release/","tags":"","title":"Release History"},{"body":"","categories":"","description":"","excerpt":"","ref":"/en/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/zh-cn/search/","tags":"","title":"Search Results"},{"body":"了解如何部署、使用 frp。\n","categories":"","description":"","excerpt":"了解如何部署、使用 frp。\n","ref":"/zh-cn/docs/","tags":"","title":"文档"},{"body":"Github Release 页面查看\n","categories":"","description":"","excerpt":"Github Release 页面查看\n","ref":"/zh-cn/release/","tags":"","title":"版本历史"}]